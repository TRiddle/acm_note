[TOC]

# 1.图论

## 1.1 最短路

### 1.1.1 单源最短路问题

#### 1.1.1.1 Dijkstra算法

代码

```c++
typedef long long ll;
typedef pair <ll, int> p;

template <class T>
struct edge {
    int to;
    T dist;
    edge() {}
    edge(int to, T dist): to(to), dist(dist) {}
};

template <class T, int maxn>
struct Dijkstra {
    T d[maxn];
    vector < edge<T> > G[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, T w) {
        G[u].push_back(edge <T> (v, w));
    }
    void solve(int n, int s, T INF) {
        priority_queue < p, vector<p>, greater<p> > pq;
        fill(d + 1, d + n + 1, INF);
        pq.push(p(0, s));
        d[s] = 0;
        while(!pq.empty()) {
            p node = pq.top();
            pq.pop();
            int u = node.second;
            if(node.first > d[u]) {
                continue;
            }
            for(int i = 0; i < G[u].size(); i++) {
                edge <T> e = G[u][i];
                int v = e.to;
                T w = e.dist;
                if(d[v] <= d[u] + w) {
                    continue;
                }
                d[v] = d[u] + w;
                pq.push(p(d[v], v));
            }
        }
    }
};
```

注意事项

1. 优先队列中的节点的距离的变量类型为$long long$ ，可能需要修改。
2. 每组输入之前要调用$initGraph()$做图的初始化，其它初始化都在$solve()$中。
3. 点的编号范围为[1, n]。

#### 1.1.1.2 Bellman-Ford算法

代码

```c++
template <class T>
struct edge {
    int v;
    T w;
    edge() {}
    edge(int v, T w): v(v), w(w) {}
};

template <class T, int maxn>
struct BellmanFord {
    vector < edge<T> > G[maxn];
    bool inq[maxn];
    int cnt[maxn];
    T d[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, T w) {
        G[u].push_back(edge <T> (v, w));
    }
    bool solve(int n, int s, T INF) {
        memset(inq, 0, sizeof(inq));
        inq[s] = true;
        memset(cnt, 0, sizeof(cnt));
        cnt[s] = 1;
        fill(d + 1, d + n + 1, INF);
        d[s] = 0;
        queue <int> q;
        q.push(s);
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for(int i = 0; i < G[u].size(); i++) {
                edge <T> e = G[u][i];
                int v = e.v;
                T w = e.w;
                if(d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    if(inq[v] == true) {
                        continue;
                    }
                    inq[v] = true;
                    q.push(v);
                    if(++ cnt[v] > n) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```

注意事项

1. solve()函数返回true表示图存在负圈。
2. 每组输入之前要调用$initGraph()$做图的初始化，其它初始化都在$solve()$中。
3. 点的编号范围为[1, n]。

#### 1.1.1.3 例题

##### 例题1 HDU5521 (2015 ACM/ICPC Asia Shenyang)

题意

有$n$个点，$m$个点集。$n$个点分别属于这些点集，同时每个点可能属于多个点集。对于一个点集$e_i$，从点集中任意一点到另一点的时间都是$t_i$。甲从点$1$ 出发，乙从点$n$出发，他们想要在某点相遇。问他们相遇的最短时间是多少。

$n$不超过$10^5$，所有点集的大小之和不超过$10^6$，$t_i$不超过$10^9$。

思路

因每个点集内都是完全图，所以不能直接建图。建图的方法是每个集合建一个虚点，虚点向集合中每个点连权值为$\frac{t_i}{2}$的边。然后分别以$1，n$为源点跑最短路。枚举甲乙的汇合点可以得解。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair <ll, int> p;
const int maxn = 1e5 + 5, maxm = 1e6 + 5;
const ll INF = 1e15 + 5;
bool vis[maxn + maxm];
int t, m, n, si, ti;
ll ans, maxTime[maxn];
vector <int> vec;

struct edge {
	int to, dist;
	edge() {}
	edge(int to, int dist): to(to), dist(dist) {}
};

struct dijkstra {
	ll d[2][maxn+maxm];
	vector <edge> G[maxn+maxm];
	void init() {
		for(int i = 1; i <= n + m; i++) {
			G[i].clear();
		}
		for(int i = 0; i < 2; i++) {
			for(int j = 1; j <= n + m; j++) {
				d[i][j] = INF;
			}
		}
	}
	void addEdge(int u, int v, int w) {
		G[u].push_back(edge(v, w));
	}
	bool dfs(int u, int t) {
		vis[u] = true;
		if(u == t) return true;
		bool res = false;
		for(int i = 0; i < G[u].size(); i++) {
			int v = G[u][i].to;
			if(!vis[v]) res |= dfs(v, t);
		}
		return res;
	}
	void SSSP(int dir, int s) {
		priority_queue < p, vector<p>, greater<p> > pq;
		pq.push(p(0, s));
		d[dir][s] = 0;
		while(!pq.empty()) {
			p node = pq.top();
			pq.pop();
			int u = node.second;
			ll dist = node.first;
			if(d[dir][u] < dist) continue;
			for(int i = 0; i < G[u].size(); i++) {
				edge& e = G[u][i];
				if(d[dir][e.to] > dist + e.dist) {
					d[dir][e.to] = dist + e.dist;
					pq.push(p(d[dir][e.to], e.to));
				}
			}
		}
	}
}o;

int main() {
	scanf("%d", &t);
	for(int kase = 1; kase <= t; kase++) {
		scanf("%d%d", &n, &m);
		o.init();
		for(int i = 1; i <= m; i++) {
			scanf("%d%d", &ti, &si);
			for(int v; si--;) {
				scanf("%d", &v);
				o.addEdge(v, n + i, ti);
				o.addEdge(n + i, v, ti);
			}
		}
		printf("Case #%d: ", kase);
		memset(vis, 0, sizeof(vis));
		bool flag = o.dfs(1, n);
		if(flag) {
			o.SSSP(0, 1);
			o.SSSP(1, n);
			for(int i = 1; i <= n; i++) {
				maxTime[i] = max(o.d[0][i], o.d[1][i]);
			}
			ans = *min_element(maxTime + 1, maxTime + n + 1);
			printf("%I64d\n", ans / 2);
			vec.clear();
			for(int i = 1; i <= n; i++) {
				if(ans == maxTime[i]) {
					vec.push_back(i);
				}
			}
			for(int i = 0; i < vec.size(); i++) {
				printf("%d", vec[i]);
				putchar(i == vec.size() - 1 ? '\n' : ' ');
			}
		}
		else puts("Evil John");
	}
	return 0;
}
```

##### 例题2(POJ3662)

题意

拉从$1$到$N$的电线：$N$个电线杆$P$条线可选，$K$条线内免费，否则花费免费额度外最长的那一根。求最小花费。

$N$不超过$10^3$， $P$不超过$10^4$ ，边权不超过$10^6$。

思路

二分花费。在花费x确定的时候判定可否做成线路。判定的方法是，对边权大于$x$的边赋予代价$1$，否则赋予代价$0$，对这种代价求$1$到$N$的最短路径看看是否小于或等于$K$。

代码

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef pair <ll, int> p;
const int maxn = 1e3 + 5, maxm = 1e4 + 5;

template <class T>
struct edge {
    int to;
    T dist;
    edge() {}
    edge(int to, T dist): to(to), dist(dist) {}
};

template <class T, int maxn>
struct Dijkstra {
    T d[maxn];
    vector < edge<T> > G[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, T w) {
        G[u].push_back(edge <T> (v, w));
    }
    void solve(int n, int s, T INF) {
        priority_queue < p, vector<p>, greater<p> > pq;
        fill(d + 1, d + n + 1, INF);
        pq.push(p(0, s));
        d[s] = 0;
        while(!pq.empty()) {
            p node = pq.top();
            pq.pop();
            int u = node.second;
            if(node.first > d[u]) {
                continue;
            }
            for(int i = 0; i < G[u].size(); i++) {
                edge <T> e = G[u][i];
                int v = e.to;
                T w = e.dist;
                if(d[v] <= d[u] + w) {
                    continue;
                }
                d[v] = d[u] + w;
                pq.push(p(d[v], v));
            }
        }
    }
    T get(int u) {
        return d[u];
    }
};

Dijkstra <ll, maxn> o;
int N, P, K, l, r, m, mid;
int u[maxm], v[maxm], s[maxm];

bool ok(int x) {
    o.initGraph(N);
    for(int i = 1; i <= P; i++) {
        if(s[i] <= x) {
            o.addEdge(u[i], v[i], 0);
            o.addEdge(v[i], u[i], 0);
        }
        else {
            o.addEdge(u[i], v[i], 1);
            o.addEdge(v[i], u[i], 1);
        }
    }
    o.solve(N, 1, maxm);
    return o.get(N) <= K;
}

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> N >> P >> K;
    for(int i = 1; i <= P; i++) {
        cin >> u[i] >> v[i] >> s[i];
        m = max(m, s[i]);
    }
    l = -1;
    r = m + 1;
    while(r - l > 1) {
        int mid = (l + r) / 2;
        if(ok(mid) == true) {
            r = mid;
        }
        else {
            l = mid;
        }
    }
    if(r == m + 1) {
        cout << -1 << endl;
        return 0;
    }
    cout << r << endl;
    return 0;
}
```

### 1.1.2 多源最短路问题

#### 1.1.2.1 Floyd算法

代码

```c++
for(k = 0; k < n; k++) { 
    for(i = 0; i < n; i++) {
        for(j = 0; j < n; j++) {
            if(A[i][j] > (A[i][k] + A[k][j])) {
                A[i][j] = A[i][k] + A[k][j];
                path[i][j] = k;
            }
        }
    }
} 
```

#### 1.1.2.2 例题

##### 例题1 （Ural1004）

大意

给你一个$n$个点加权无向图，要你从里面找一个路径最短的环，每个点只能经过一次 ，如果存在这样的最短环则把路径给打印出来，如果有多个，打印一个出来即可。

思路

首先容易想到的是暴力来枚举环，当删除其中一条边$ij$后再跑一边从$i$到$j$的最短路，然后加上边$ij$的值就是含有边$ij$的最小环的值，这样最坏的。时间复杂度可以达到$O(n^4)$，显然复杂度有点大。所以我们考虑降低时间复杂度，我们来分析下$Floyd$的实现过程，当枚举顶点$k$之前我们已经求得了顶点为$1  -  k-1$ 的最短路，所以我们可以在更新$k$之前枚举$k$之前的$i$和$j$的组合，我们可以知道$dis[i][j]$没有经过$k$点,所以我们就可以知道如果$dis[i][j]+mp[i][k]+mp[k][j]  !=  INF$($mp[i][j]$为没有跟新得边值) 时就存在一条经过$i-j-k$的最小环,所以我们要求的是所有环当中最小的那一个。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn=110;
const int INF=0x7ffffff;
int  dist[maxn][maxn], map[maxn][maxn];
int  pre[maxn][maxn];
int  path[maxn];
int  n, m, num, minc;

void floyd() {
    minc = INF;
    for(int k = 1; k <= n; k++) {
        for(int i = 1; i < k; i++) {
            for(int j = i + 1; j < k; j++) {
                int ans = dist[i][j] + map[i][k] + map[k][j];
                if(ans < minc) { //找到最优解
                    minc = ans;
                    num = 0;
                    int p = j;
                    while(p != i) { //逆向寻找前驱遍历的路径并将其存储起来
                        path[num ++] = p;
                        p = pre[i][p];
                    }
                    path[num++] = i;
                    path[num++] = k;
                }
            }
    	}
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                if(dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    pre[i][j] = pre[k][j];
                }
            }
        }
    }
}

int main() {
    int  u, v, cost;
    while(cin >> n) {
        if(n < 0) {
          break;
        }
        cin >> m;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                dist[i][j] = map[i][j] = INF;
                pre[i][j] = i;
            }
        }
        for(int i = 1; i <= m; i++) {
            scanf("%d%d%d", &u, &v, &cost);
            if(dist[u][v] > cost) {  //处理重边
                map[u][v] = map[v][u] = dist[u][v] = dist[v][u] = cost;
            }
        }
        floyd();
        if(minc == INF) {
            printf("No solution.\n");
        }
        else {
            printf("%d", path[0]);
            for(int i = 1; i < num; i++) {
                printf(" %d",path[i]);
            }
            puts("");
        }
    }
    return 0;
}
```



### 1.1.3 差分约束问题

#### 1.1.3.1 Bellman-Ford算法

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 1e3 + 10;
const ll INF = 1e9;

struct edge {
    int v;
    ll w;
    edge() {}
    edge(int v, ll w): v(v), w(w) {}
};

struct BellmanFord {
    vector <edge> G[maxn];
    bool inq[maxn];
    int cnt[maxn];
    ll d[maxn];
    void addEdge(int u, int v, ll w) {
        G[u].push_back(edge(v, w));
    }
    void initGraph(int n) {
        for(int i = 0; i <= n; i++) {
            G[i].clear();
        }
    }
    bool solve(int n, int s) {
       memset(inq, false, sizeof(inq));
       inq[s] = true;
       memset(cnt, 0, sizeof(cnt));
       cnt[s] = 1;
       fill(d + 0, d + n + 1, INF);
       d[s] = 0;
       queue <int> q;
       while(!q.empty()) {
           q.pop();
       }
       q.push(s);
        // 解决不连通的问题
        for(int i = 1; i <= n; i++) {
            inq[i] = true;
            q.push(i);
        }
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for(int i = 0; i < G[u].size(); i++) {
                edge e = G[u][i];
                int v = e.v;
                ll w = e.w;
                if(d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    ++ cnt[v];
                    if(cnt[v] > n) {
                        return true;
                    }
                    if(inq[v] == false) {
                        inq[v] = true;
                        q.push(v);
                    }
                }
            }
        }
        return false;
    }
};
```

#### 1.1.3.2 例题

##### 例题1 （UESTC1646）

题意

求一个有$n$个元素的数列，满足任意连续$p$个数的和不小于$s$，任意连续$q$个数的和不大于$t$。
思路
令$sum[i]$表示前$i$项的和$(0 \leq i \leq n,sum[0]=0)$
那么题目的条件可转化为：
$sum[i]-sum[i-p] \leq s (p \leq i \leq n)$
$sum[i]-sum[i-q] \leq t (q \leq i \leq n)$
将第一个不等式取反，得到
$sum[i-p]-sum[i] \leq -s(p \leq i \leq n)$
于是问题转化为求一系列不等式的解，这是一个典型的差分约束问题。

考虑最短路径的性质，令$dis[i]$表示从$s$到$i$的最短路，则对于图中存在的一条边$(u,v)$有

$dis[v] \leq dis[u]+w(u,v)$ 即

$dis[v]-dis[u] \leq w(u,v)$
类比不等式建图，$i$向$i-p$引长度为$-s$的边，$i-q$向$i$引长度为$t$的边。
然后运行Bellman-Ford，如果存在负环，则无解，
否则所得到的最短路的值就是$sum[i]$的一个解。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 1e3 + 10;
const ll INF = 1e9;

struct edge {
    int v;
    ll w;
    edge() {}
    edge(int v, ll w): v(v), w(w) {}
};

struct BellmanFord {
    vector <edge> G[maxn];
    bool inq[maxn];
    int cnt[maxn];
    ll d[maxn];
    void addEdge(int u, int v, ll w) {
        G[u].push_back(edge(v, w));
    }
    void initGraph(int n) {
        for(int i = 0; i <= n; i++) {
            G[i].clear();
        }
    }
    bool solve(int n, int s) {
       memset(inq, false, sizeof(inq));
       inq[s] = true;
       memset(cnt, 0, sizeof(cnt));
       cnt[s] = 1;
       fill(d + 0, d + n + 1, INF);
       d[s] = 0;
       queue <int> q;
       while(!q.empty()) {
           q.pop();
       }
       q.push(s);
        // 解决不连通的问题
        for(int i = 1; i <= n; i++) {
            inq[i] = true;
            q.push(i);
        }
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for(int i = 0; i < G[u].size(); i++) {
                edge e = G[u][i];
                int v = e.v;
                ll w = e.w;
                if(d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    ++ cnt[v];
                    if(cnt[v] > n) {
                        return true;
                    }
                    if(inq[v] == false) {
                        inq[v] = true;
                        q.push(v);
                    }
                }
            }
        }
        return false;
    }
}o;

int n, p, q, s, t;

int main() {
    scanf("%d%d%d%d%d", &n, &p, &q, &s, &t);
    o.initGraph(n);
    for(int i = 0; i <= n; i++) {
        if(i - p >= 0) {
            o.addEdge(i, i - p, -s);
        }
        if(i - q >= 0) {
            o.addEdge(i - q, i, t);
        }
    }
    if(o.solve(n, 0)) {
        puts("No");
        return 0;
    }
    puts("Yes");
    for(int i = 1; i <= n; i++) {
        printf("%lld", o.d[i] - o.d[i - 1]);
        putchar(i == n ? '\n' : ' ');
    }
    return 0;
}
```

## 1.2 网络流

### 1.2.1 最大流问题

#### 1.2.1.1 Dinic算法

代码

```c++
typedef long long ll;
const int maxn = 210, maxm = 3e5;
const ll INF = 2e9;

struct edge {
    int v;
    ll cap;
    edge() {}
    edge(int v, ll cap): v(v), cap(cap) {}
};

struct Dinic {
    vector <int> G[maxn];
    vector <edge> edges;
    int level[maxn], iter[maxn];
    void initGraph(int n) {
        edges.clear();
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, ll w) {
        G[u].push_back(edges.size());
        edges.push_back(edge(v, w));
        G[v].push_back(edges.size());
        edges.push_back(edge(u, 0));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = edges[G[u][i]];
                int v = e.v;
                ll c = e.cap;
                if(c > 0 && level[v] < 0) {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    ll dfs(int u, int t, ll f) {
        if(u == t) {
            return f;
        }
        for(int& i = iter[u]; i < G[u].size(); i++) {
            edge& e = edges[G[u][i]];
            edge& re = edges[G[u][i] ^ 1];
            int v = e.v;
            ll& c = e.cap;
            if(c > 0 && level[u] < level[v]) {
                ll d = dfs(v, t, min(f, c));
                if(d > 0) {
                    c -= d;
                    re.cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    ll solve(int s, int t) {
        ll flow = 0;
        while(true) {
            bfs(s);
            if(level[t] < 0) {
                return flow;
            }
            ll f;
            memset(iter, 0, sizeof(iter));
            while((f = dfs(s, t, INF)) > 0) {
                flow += f;
            }
        }
    }
}o;
```

注意事项

1. 别忘了cap变量类型为$longlong$。
2. 每组输入之前要做图的初始化，其它初始化都在$solve()$中。
3. $G[u][i] \oplus 1$ 可以取到$G[u][i]$ 的反向边的编号。
4. 用$(G[u][i] \oplus 1).cap$ 可以方便地查看编号为$G[u][i]$ 的边的流量。
5. 点的编号是从1到n的。

#### 1.2.1.2 ISAP算法

代码

```c++
const int maxn = 210, maxm = 3e5;
const ll INF = 2e9;

struct edge {
    int from, to, cap;
    edge() {}
    edge(int from, int to, int cap): from(from), to(to), cap(cap) {}
};

struct ISAP {
    int d[maxn], cur[maxn], p[maxm], num[maxn];
    int cnt, first[maxn], next[maxm];
    edge edges[maxm];
    void init() {
        cnt = 0;
        memset(first, -1, sizeof(first));
    }
    void addEdge(int u, int v, int w) {
        edges[cnt] = edge(u, v, w);
        next[cnt] = first[u];
        first[u] = cnt ++;
        edges[cnt] = edge(v, u, 0);
        next[cnt] = first[v];
        first[v] = cnt ++;
    }
    void bfs(int t) {
        queue <int> q;
        memset(d, -1, sizeof(d));
        d[t] = 0;
        for(q.push(t); !q.empty();) {
            int u = q.front();
            q.pop();
            for(int i = first[u]; i != -1; i = next[i]) {
                edge &e = edges[i];
                if(d[e.to] < 0) {
                    d[e.to] = d[u] + 1;
                    q.push(e.to);
                }
            }
        }
    }
    int augment(int s, int t) {
        int d = INF;
        for(int x = t; x != s; x = edges[p[x]].from) {
            d = min(d, edges[p[x]].cap);
        }
        for(int x = t; x != s; x = edges[p[x]].from) {
            edges[p[x]].cap -= d;
            edges[p[x] ^ 1].cap += d;
        }
        return d;
    }
    bool advance(int& x) {
        for(int& i = cur[x]; i != -1; i = next[i]) {
            edge& e = edges[i];
            if(e.cap > 0 && d[x] == d[e.to] + 1) {
                p[e.to] = i;
                x = e.to;
                return true;
            }
        }
        return false;
    }
    bool retreat(int n, int s, int &x) {
        int m = n;
        for(int i = first[x]; i != -1; i = next[i]) {
            edge& e = edges[i];
            if(e.cap > 0) {
                m = min(m, d[e.to]);
            }
        }
        if(--num[d[x]] == 0) {
            return false;
        }
        num[d[x] = m + 1] ++;
        cur[x] = first[x];
        if(x != s) {
            x = edges[p[x]].from;
        }
        return true;
    }
    int solve(int n, int s, int t) {
        int flow = 0;
        bfs(t);
        memcpy(cur, first, sizeof(first));
        memset(num, 0, sizeof(num));
        for(int i = 1; i <= n; i++) {
            num[d[i]] ++;
        }
        for(int x = s; d[s] <= n;) {
            if(x == t) {
                flow += augment(s, t);
                x = s;
            }
            if(!advance(x) && !retreat(n, s, x)) {
                break;
            }
        }
        return flow;
    }
};
```

注意事项

1. 无论有没有多组输入，都要注意调用init函数做初始化，还要做图的初始化。其它的初始化都在solve函数中。
2. 要注意结构体依赖的常量。
3. 点的编号是从1到n的。

#### 1.2.1.3 例题

##### 例题1 HDU1532

题意

给一个管道图，求点1到点N之间的最大流。图按照以下的方式给出。第一行包括两个整数M, N表示图中有N个点M个管道。接下来的M行，每行包括三个整数u, v, w，表示点u和点v之间有一个容量为w的管道。

（$N, M \leq 200, 1 \leq u, v \leq N, w \leq 10^7$）

思路

裸的最大流题目。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 210;
const ll INF = 2e9;

struct edge {
    int v, rev;
    ll cap;
    edge() {}
    edge(int v, ll cap, int rev): v(v), cap(cap), rev(rev) {}
};

struct Dinic {
    vector <edge> G[maxn];
    int level[maxn], iter[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, ll w) {
        G[u].push_back(edge(v, w, G[v].size()));
        G[v].push_back(edge(u, 0, G[u].size() - 1));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = G[u][i];
                int v = e.v;
                ll c = e.cap;
                if(c > 0 && level[v] < 0) {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    ll dfs(int u, int t, ll f) {
        if(u == t) {
            return f;
        }
        for(int& i = iter[u]; i < G[u].size(); i++) {
            edge& e = G[u][i];
            int v = e.v;
            int r = e.rev;
            ll& c = e.cap;
            if(c > 0 && level[u] < level[v]) {
                ll d = dfs(v, t, min(f, c));
                if(d > 0) {
                    c -= d;
                    G[v][r].cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    ll solve(int s, int t) {
        ll flow = 0;
        while(true) {
            bfs(s);
            if(level[t] < 0) {
                return flow;
            }
            ll f;
            memset(iter, 0, sizeof(iter));
            while((f = dfs(s, t, INF)) > 0) {
                flow += f;
            }
        }
    }
}o;

int n, m, u, v, w;

int main() {
    while(scanf("%d%d", &m, &n) == 2) {
        o.initGraph(n);
        while(m--) {
            scanf("%d%d%d", &u, &v, &w);
            o.addEdge(u, v, w);
        }
        printf("%I64d\n", o.solve(1, n));
    }
    return 0;
}
```

##### 例题2 POJ3281

题意

农夫约翰为他的N头牛准备了F种食物和D种饮料。每头牛都有各自喜欢的食物和饮料，

而每种食物或饮料只能分配给一头牛。最多能有多少头牛可以同时的到喜欢的食物和饮料。

思路

这是典型的分配问题。从源点连容量为1的边到每种食物，再从饮料连容量为1的边到汇点。

如果只是这样的话可能会出现问题，那就是可能从很多种食物来的流量流过同一只牛，

又流到另外几个饮料那儿去。因此要对流过牛的流量进行管制。

最好的办法是对牛进行拆点。对两点之间连容量为1的边。

代码

```c++
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

const int maxv = 405;
const int INF = 205;

struct edge {
    int from, to, cap;
    edge(int from, int to, int cap): from(from), to(to), cap(cap) {}
};

struct dinic {
    int level[maxv], iter[maxv];
    vector <edge> edges;
    vector <int> G[maxv];
    void addedge(int u, int v, int c) {
        G[u].push_back(edges.size());
        edges.push_back(edge(u, v, c));
        G[v].push_back(edges.size());
        edges.push_back(edge(v, u, 0));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s]=0;
        while(!q.empty()) {
            int u=q.front();
            q.pop();
            for(int i=0; i<G[u].size(); i++) {
                edge& e=edges[G[u][i]];
                if(e.cap>0 && level[e.to]<0) {
                    level[e.to]=level[u]+1;
                    q.push(e.to);
                }
            }
        }
    }
    int dfs(int u, int t, int f) {
        if(u == t) return f;
        for(int &i=iter[u]; i<G[u].size(); i++) {
            edge& e=edges[G[u][i]];
            if(e.cap>0 && level[e.to]>level[u]) {
                int d=dfs(e.to, t, min(f, e.cap));
                if(d>0) {
                    e.cap -= d;
                    edges[G[u][i]^1].cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    int max_flow(int s, int t) {
        for(int flow=0;;) {
            bfs(s);
            if(level[t]<0) return flow;
            int f;
            memset(iter, 0, sizeof(iter));
            while((f=dfs(s, t, INF))>0) flow += f;
        }
    }
}solver;

int main() {
    int n, f, d, fi, di, food, drink;
    scanf("%d%d%d", &n, &f, &d);
    int s=0, t=f+2*n+d+1;
    for(int i=1; i <= n; i++) {
        scanf("%d%d", &fi, &di);
        for(int j=0; j<fi; j++) {
            scanf("%d", &food);
            solver.addedge(food, f+i, 1);
        }
        for(int j=0; j<di; j++) {
            scanf("%d", &drink);
            solver.addedge(f+n+i, f+2*n+drink, 1);
        }
        solver.addedge(f+i, f+n+i, 1);
    }
    for(int i=1; i <= f; i++) solver.addedge(s, i, 1);
    for(int i=1; i <= d; i++) solver.addedge(f+2*n+i, t, 1);
    printf("%d\n", solver.max_flow(s, t));
    return 0;
}
```

### 1.2.2 费用流问题

#### 1.2.2.1 最短增广路算法（基于Bellman-Ford算法）

代码

```c++
const int maxv = 1e3 + 10;
const int INF = 1e9;

struct edge {
	int from, to, cap, flow, cost;
	edge(int from, int to, int cap, int flow, int cost):
		from(from), to(to), cap(cap), flow(flow), cost(cost) {}
};

// 点的编号的范围为[1, n]
struct MCMF {
    vector <edge> edges;
    vector <int> G[maxv];
    int inq[maxv];			// 是否在队列中
    int d[maxv];			// Bellman-Ford
    int p[maxv];			// 上一条弧
    int a[maxv];			// 可改进量
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
        edges.clear();
    }
    void addEdge(int u, int v, int c, int w) {
        G[u].push_back(edges.size());
        edges.push_back(edge(u, v, c, 0, w));
        G[v].push_back(edges.size());
        edges.push_back(edge(v, u, 0, 0, -w));
    }
    bool BellmanFord(int n, int s, int t, int& flow, int& cost, int k) {
        fill(d + 1, d + n + 1, INF);
        d[s] = 0;
        memset(inq, 0, sizeof(inq));
        inq[s] = 1;
        queue <int> q;
        q.push(s);
        a[s] = INF;
        p[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = edges[G[u][i]];
                int v = e.to;
                int w = e.cost;
                int f = e.flow;
                int c = e.cap;
                if(c > f && d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    p[v] = G[u][i];
                    a[v] = min(a[u], c - f);
                    if(!inq[v]) {
                        q.push(v);
                        inq[v] = 1;
                    }
                }
            }
        }
        if(d[t] == INF) {
            return false;
        }
        if(flow + a[t] > k) {
            flow += (k - flow);
            return false;
        }
        flow += a[t];
        cost += d[t] * a[t];
        for(int u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u]^1].flow -= a[t];
        }
        return true;
    }
    // 若要指定流量则给INF赋值
    int minCost(int n, int s, int t, int k = INF) {
        int flow = 0, cost = 0;
        while(BellmanFord(n, s, t, flow, cost, k));
        return cost;
    }
};
```

注意事项

1. 要注意给常量赋值。
2. 点的编号范围是1到n。
3. 默认为最小费用最大流，若要指定流量则要在minCost函数里给k赋值。

#### 1.2.2.2 最短增广路算法（基于Dijkstra算法）

代码

```c++
typedef pair<int, int> P;
const int maxv = 1e3 +10, INF = 1e9;

struct Edge {
    int to, cap, cost, rev;
    Edge() {}
    Edge(int to, int cap, int cost, int rev):
        to(to), cap(cap), cost(cost), rev(rev) {}
};

struct MCF {
    vector <Edge> G[maxv];
    // 最短路中的前驱节点和对应的边
    int prevv[maxv], preve[maxv];
    // 最短距离
    int dist[maxv];
    // 顶点的势
    int h[maxv];
    int V;
    // 使用前务必调用次函数
    void initGraph(int n) {
        V = n;
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int from, int to, int cap, int cost) {
        G[from].push_back(Edge(to, cap, cost, G[to].size()));
        G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
    }
    // 返回最小费用
    // 如果没有流量达到f的流，则返回-1
    int minCostFlow(int s, int t, int f) {
        int res = 0;
        fill(h + 1, h + V + 1, 0);
        while(f > 0) {
            // 使用Dijkstra算法更新h
            priority_queue < P, vector<P>, greater<P> > que;
            fill(dist + 1, dist + V + 1, INF);
            dist[s] = 0;
            que.push(P(0, s));
            while(!que.empty()) {
                P p = que.top();
                que.pop();
                int u = p.second;
                if(dist[u] < p.first) {
                    continue;
                }
                for(int i = 0; i < G[u].size(); i++) {
                    Edge &e = G[u][i];
                    int v = e.to;
                    int cost = e.cost;
                    int cap = e.cap;
                    int tmp = dist[u] + cost + h[u] - h[v];
                    if(cap > 0 && dist[v] > tmp) {
                        dist[v] = tmp;
                        prevv[v] = u;
                        preve[v] = i;
                        que.push(P(dist[v], v));
                    }
                }
            }
            // 不能再增广
            if(dist[t] == INF) {
                return -1;
            }
            for(int v = 1; v <= V; v ++) {
                h[v] += dist[v];
            }
            // 沿s到t的最短路尽量增广
            int d = f;
            for(int v = t; v != s; v = prevv[v]) {
                d = min(d, G[prevv[v]][preve[v]].cap);
            }
            f -= d;
            res += d * h[t];
            for(int v = t; v != s; v = prevv[v]) {
                Edge &e = G[prevv[v]][preve[v]];
                e.cap -= d;
                G[v][e.rev].cap += d;
            }
        }
        return res;
    }
};
```

注意事项

1. 要注意给常量赋值。
2. 使用前调用initGraph函数给V和图初始化，其它初始化在solve函数中。
3. 点的编号从1到n。

#### 1.2.2.3 例题

##### 例题1  POJ2135

题意

在一个无向图中，问从1走到n再从n走回1的最短路径长度是多少。每条边只能走一次。

思路

对图建立网络。每条边的流量为1费用为边的长度。求流量为2的最小费用流。

代码

```c++
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

typedef pair<int, int> P;
const int maxv = 1e3 +10, INF = 1e9;

struct Edge {
    int to, cap, cost, rev;
    Edge() {}
    Edge(int to, int cap, int cost, int rev):
        to(to), cap(cap), cost(cost), rev(rev) {}
};

struct MCF {
    vector <Edge> G[maxv];
    // 最短路中的前驱节点和对应的边
    int prevv[maxv], preve[maxv];
    // 最短距离
    int dist[maxv];
    // 顶点的势
    int h[maxv];
    int V;
    // 使用前务必调用次函数
    void initGraph(int n) {
        V = n;
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int from, int to, int cap, int cost) {
        G[from].push_back(Edge(to, cap, cost, G[to].size()));
        G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
    }
    // 返回最小费用
    // 如果没有流量达到f的流，则返回-1
    int minCostFlow(int s, int t, int f) {
        int res = 0;
        fill(h + 1, h + V + 1, 0);
        while(f > 0) {
            // 使用Dijkstra算法更新h
            priority_queue < P, vector<P>, greater<P> > que;
            fill(dist + 1, dist + V + 1, INF);
            dist[s] = 0;
            que.push(P(0, s));
            while(!que.empty()) {
                P p = que.top();
                que.pop();
                int u = p.second;
                if(dist[u] < p.first) {
                    continue;
                }
                for(int i = 0; i < G[u].size(); i++) {
                    Edge &e = G[u][i];
                    int v = e.to;
                    int cost = e.cost;
                    int cap = e.cap;
                    int tmp = dist[u] + cost + h[u] - h[v];
                    if(cap > 0 && dist[v] > tmp) {
                        dist[v] = tmp;
                        prevv[v] = u;
                        preve[v] = i;
                        que.push(P(dist[v], v));
                    }
                }
            }
            // 不能再增广
            if(dist[t] == INF) {
                return -1;
            }
            for(int v = 1; v <= V; v ++) {
                h[v] += dist[v];
            }
            // 沿s到t的最短路尽量增广
            int d = f;
            for(int v = t; v != s; v = prevv[v]) {
                d = min(d, G[prevv[v]][preve[v]].cap);
            }
            f -= d;
            res += d * h[t];
            for(int v = t; v != s; v = prevv[v]) {
                Edge &e = G[prevv[v]][preve[v]];
                e.cap -= d;
                G[v][e.rev].cap += d;
            }
        }
        return res;
    }
}o;

int n, m, u, v, w;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    o.initGraph(n);
    while(m--) {
        cin >> u >> v >> w;
        o.addEdge(u, v, 1, w);
        o.addEdge(v, u, 1, w);
    }
    cout << o.minCostFlow(1, n, 2) << endl;
    return 0;
}
```

##### 例题2 HDU5644

题意

王国每天都需要$p[i]$个飞行员进行阅兵，飞行员只工作一天。 $m$个休假公式，花费$t[i]$元让飞行员在休假$s[i]$天后回来上班。 可以花费$Q$元雇佣新的飞行员，但是直到$P$天后才能上班。问能让王国的阅兵每天都有足够飞行员的最小花费是多少。

$n$不超过$200$， $m$不超过$5$。

思路

读题以后发现这是个最优化问题。并且与解相关的量太多，似乎用贪心，搜索和动态规划都不好办。但发现题目中的条件有点“供需关系”的意思。于是考虑是否能用网络流（这里应该是费用流）来解决。
先设置 $n$ 个点（编号从 $n + 1$ 到 $n + n$ ，原因稍后解释）表示第n天。

首先从源点（编号为 $0$ ）引一条容量和费用为 $(k, 0)$ 边到点 $1$ ，然后对每个点 $i$ 连一条到 $i+1$ 的边 $(INF, 0)$ 。这两种边表示初始的时候有 $k$ 个飞行员，使用他们是免费的。

现在考虑飞行员的训练制度。首先从源点引一条到 $P$ 点的边 $(INF, Q)$ ，表示第 $P$ 天就可以使用训练好的飞行员了，这些飞行员的供应是无限的，但每位飞行员要付 $Q$ 单位的钱。

最后考虑飞行员的休假制度。对每个点 $i$ 连一条边 $(p[i], 0)$ 到汇点 $t$ ，表示每天都有 $p[i]$ 位飞行员要去休假。那么休假的飞行员回来的关系该如何表示呢？如果直接从源点向表示“第 $i$ 天”的点引边的话，只能表示 $1$ 种休假制度，但是我们有m种休假制度。所以显然不能直接这样引边。那么我们能不能先把飞行员囤在某些点上，然后依照不同的休假制度，用不同的方法从这些点向第 $i$ 天供应呢？显然是可以的。我们将第 $i$ 天的点拆成 $x_i$ （编号从 $1$ 到 $n$ ）和 $y_i$ （编号从 $n + 1$ 到 $n + n$ ） ， $y_i$ 保持原来“第 $i$ 天的点”的连边方式， $x_i$ 要重新连不同的边（这就是为什么之前要把表示第 $i$ 天的点从 $n + 1$ 编号到 $n + n$ ）。从源点向 $x_i$ 引边 $(p[i], 0)$ ，表示每天都有 $p[i]$ 个飞行员去休假。然后从 $x_i$ 向 $y_{i+t[j]}$ 引边 $(INF, s[j])$ ，表示对第 $j$ 种休假方案，过了 $t[j]$ 天后花 $s[j]$ 元钱就能将休假结束的飞行员请回来。
这样，图就建好了。对这个图运行一次最小费用最大流。当最大流等于 $\sum\limits_ {i = 1}^n p[i]$ 的时候最小费用就是解。否则无解。

代码

```c++
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

const int maxn = 405, maxm = 10, INF = 1e9;
int cs, n, k, m, P, Q, S, T, sum, ans, p[maxn], s[maxm], t[maxm];

// 存储边的信息的结构体
struct edge {
	int from, to, cap, flow, cost;
	edge(int from, int to, int cap, int flow, int cost): 
		from(from), to(to), cap(cap), flow(flow), cost(cost) {}
};

// 最小费用最大流模板
struct MCMF {
	int v;
	vector <edge> edges;
	vector <int> G[maxn];
	int inq[maxn];			// 是否在队列中
	int d[maxn];			// Bellman-Ford
	int p[maxn];			// 上一条弧
	int a[maxn];			// 可改进量
	void init(int v) {
		this->v = v;
		for(int i = 0; i < v; i++) {
			G[i].clear();
		}
		edges.clear();
	}
	// 往邻接表中添加一条边
	void addEdge(int from, int to, int cap, int cost) {
		G[from].push_back(edges.size());
		edges.push_back(edge(from, to, cap, 0, cost));
		G[to].push_back(edges.size());
		edges.push_back(edge(to, from, 0, 0, -cost));
	}
	// 用Bellman-Ford算法寻找最短增广路
	bool BellmanFord(int s, int t, int& flow, int& cost) {
		for(int i = 0; i < v; i++) {
			d[i] = INF;
		}
		memset(inq, 0, sizeof(inq));
		d[s] = 0;
		inq[s] = 1;
		p[s] = 0;
		a[s] = INF;
		queue <int> q;
		q.push(s);
		while(!q.empty()) {
			int u = q.front();
			q.pop();
			inq[u] = 0;
			for(int i = 0; i < G[u].size(); i++) {
				edge& e = edges[G[u][i]];
				if(e.cap > e.flow && d[e.to] > d[u] + e.cost) {
					d[e.to] = d[u] + e.cost;
					p[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to]) {
						q.push(e.to);
						inq[e.to] = 1;
					}
				}
			}
		}
		if(d[t] == INF) return false; // s-t不连通，失败退出
		flow += a[t];
		cost += d[t] * a[t];
		for(int u = t; u != s; u = edges[p[u]].from) {
			edges[p[u]].flow += a[t];
			edges[p[u]^1].flow -= a[t];
		}
		return true;
	}
	// 解出最小费用和最大流
	int Mincost(int s, int t) {
		int flow = 0, cost = 0;
		while(BellmanFord(s, t, flow, cost));
		if(flow == sum) return cost;
		else return -1;
	}
}o;

int main() {
	scanf("%d", &cs);
	while(cs--) {
		scanf("%d%d", &n, &k);
		sum = 0;
		for(int i = 1; i <= n; i++) {
			scanf("%d", &p[i]);
			sum += p[i];
		}
		scanf("%d%d%d", &m, &P, &Q);
		for(int i = 1; i <= m; i++) {
			scanf("%d%d", &s[i], &t[i]);
		}
		S = 0, T = 2 * n + 1;
		// 初始化邻接表
		o.init(2 * n + 2);
		// 供应初始的免费飞行员
		o.addEdge(S, n + 1, k, 0);
		// 供应训练好的飞行员
		if(P <= n) {
			o.addEdge(S, n + P, INF, Q);
		}
		// 存储休假回来的飞行员
		for(int i = 1; i <= n; i++) {
			o.addEdge(S, i, p[i], 0);
		}
		// 供应休假回来的飞行员
		for(int i = 1; i <= m; i++) {
			for(int j = 1; j + t[i] <= n; j++) {
				o.addEdge(j, n + j + t[i], INF, s[i]);
			}
		}
		// 使用前几天未使用的飞行员
		for(int i = 1; i < n; i++) {
			o.addEdge(n + i, n + i + 1, INF, 0);
		}
		// 飞行员去休假
		for(int i = 1; i <= n; i++) {
			o.addEdge(n + i, T, p[i], 0);
		}
		// 判断是否有解并输出
		ans = o.Mincost(S, T);
		if(ans < 0) {
			puts("No solution");
		}
		else printf("%d\n", ans);
	}
	return 0;
}
```

##### 例题3 HDU5988(2016 ACM/ICPC Asia Qingdao)

题意

有$N$个点和$M$条有向边。每个点$i$有$s_i$个人和$b_i$份物资。每个人可以通过边去到途中的另一个点。每条边$i$只能允许$c_i$个人通过，并且除了第$1$个通过的人外，每通过一个人都会有$p_i$的概率使得这个图崩溃。求能使每人能得到$1$份物资的最小的崩溃概率。

$N$不超过$100$，$M$不超过$5000$。$s_i, b_i$不超过$200$。$c_i$不超过$100$。

思路

首先解决概率部分的问题。如果已经给出方案（每条边过多少个人）。如何求概率？崩溃的概率比较难求（任意一个人都可能使图崩溃），所以转而求不崩溃的概率。当每个边的不崩溃的概率相乘就可以得到总的不崩溃的概率，而每个边的不崩溃的概率等于。

其次，来解决如何分配的问题。分配问题可以用最小费用流来解决。但是最小费用在计算费用的时候只支持累加操作不支持累乘操作。假设崩溃的概率为$p_i$, 不崩溃的概率为$q_i = 1 - p_i$，令$l_i = log(p_i)$。令$l_i$为费用的话如果求出最大费用流就可以解决问题。因此将$l_i$取负（正好使其成为正数），对图做最小费用流即可解决问题。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

//first保存最短距离，second保存顶点的编号
typedef pair <double, int> P;
const int maxn = 110;
const double INF = 1e15, eps = 1e-10;

struct Edge {
    //终点，容量（指残量网络中的），费用，反向边编号
    int to, cap, rev;
    double cost;
    Edge(int t, int c, double cc, int r) :to(t), cap(c), cost(cc), rev(r){}
};

vector <Edge> G[maxn]; // 图的邻接表
int V; // 顶点数
int prevv[maxn]; // 最短路中的父结点
int preve[maxn]; // 最短路中的父边
double dist[maxn]; // 最短距离
double h[maxn]; // 顶点的势

int cmp(double x) {
    if(x < -eps) {
        return -1;
    }
    return x > eps;
}

void addEdge(int from, int to, int cap, double cost) {
    G[from].push_back(Edge( to, cap, cost, G[to].size()));
    G[to].push_back(Edge( from, 0, -cost, G[from].size() - 1 ));
}

// 返回最小费用
double min_cost_flow(int s, int t, int f) {
    double res = 0;
    fill(h, h + V, 0);
    // f > 0时还需要继续增广
    while (f > 0) {
        priority_queue < P, vector<P>, greater<P> >q;
        // 距离初始化为INF
        fill(dist, dist + V, INF);
        dist[s] = 0;
        q.push(P(0, s));
        while (!q.empty()) {
            P p = q.top(); q.pop();
            int v = p.second;
            // p.first是v入队列时候的值，dist[v]是目前的值，如果目前的更优，扔掉旧值
            if (cmp(dist[v] - p.first) < 0) {
                continue;
            }
            for (int i = 0; i<G[v].size(); i++) {
                Edge&e = G[v][i];
                // 松弛操作
                if (e.cap > 0 && cmp(dist[e.to] - (dist[v] + e.cost + h[v] - h[e.to])) > 0) {
                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];
                    // 更新父结点
                    prevv[e.to] = v;
                    // 更新父边编号
                    preve[e.to] = i;
                    q.push(P(dist[e.to], e.to));
                }
            }
        }
        // 如果dist[t]还是初始时候的INF，那么说明s-t不连通，不能再增广了
        if (dist[t] == INF) {
            return -1;
        }
        //更新h
        for (int j = 0; j<V; j++) {
            h[j] += dist[j];
        }
        int d = f;
        for (int x = t; x != s; x = prevv[x]) {
            //从t出发沿着最短路返回s找可改进量
            d = min(d, G[prevv[x]][preve[x]].cap);
        }
        f -= d;
        // h[t]表示最短距离的同时
        // 也代表了这条最短路上的费用之和，乘以流量d即可得到本次增广所需的费用
        res += d * h[t];
        for (int x = t; x != s; x = prevv[x]) {
            Edge&e = G[prevv[x]][preve[x]];
            //修改残量值
            e.cap -= d;
            G[x][e.rev].cap += d;
        }
    }
    return res;
}

double getCost(double pro) {
    double res = log(pro);
    return -res;
}

double getPro(double cost) {
    double res = -cost;
    return exp(res);
}

const int MAXN = 110, MAXM = 5010;
int T, n, m, head, tail, mid, totFlow, minsb;
int s[MAXN], b[MAXN], u[MAXM], v[MAXM], c[MAXM];
double mcf, p[MAXM];

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d", &n, &m);
        totFlow = 0;
        for(int i = 1; i <= n; i++) {
            scanf("%d%d", &s[i], &b[i]);
            minsb = min(b[i], s[i]);
            b[i] -= minsb;
            s[i] -= minsb;
            totFlow += s[i];
        }
        for(int i = 1; i <= m; i++) {
            scanf("%d%d%d%lf", &u[i], &v[i], &c[i], &p[i]);
        }
        head = 0;
        tail = n + 1;
        V = tail + 1;
        for(int i = 0; i < V; i++) {
            G[i].clear();
        }
        for(int i = 1; i <= n; i++) {
            if(b[i] == 0 && s[i] == 0) {
                continue;
            }
            else if(b[i] == 0) {
                addEdge(head, i, s[i], 0);
            }
            else if(s[i] == 0) {
                addEdge(i, tail, b[i], 0);
            }
        }
        for(int i = 1; i <= m; i++) {
            if(c[i] < 1) {
                continue;
            }
            addEdge(u[i], v[i], 1, 0);
            addEdge(u[i], v[i], c[i] - 1, getCost(1 - p[i]));
        }
        mcf = min_cost_flow(head, tail, totFlow);
        printf("%.2f\n", 1 - getPro(mcf));
    }
    return 0;
}
```

### 1.2.3 最小割问题

#### 1.2.3.1 求最小割

##### 例题 HDU6214 (2017 ACM/ICPC Asia Qingdao Online)

题意

求有向图图的最小割，如果有多组答案，求割集中边的数量最小的那个。

组数$T$ 不超过$300$，点数$N$不超过$200$，边数$M$不超过$1000$，边上的流量不超过$255$。

思路

最小割问题转化成求最大流的问题。每条边的流量乘$255$（代码中直接乘了$1000$）然后加$1$。

这样就在优先考虑流量最大的前提下考虑了边的数量。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 210, INF = 1e9;

struct edge {
    int v, rev, cap;
    edge() {}
    edge(int v, int cap, int rev): v(v), cap(cap), rev(rev) {}
};

struct Dinic {
    vector <edge> G[maxn];
    int level[maxn], iter[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, int w) {
        G[u].push_back(edge(v, w, G[v].size()));
        G[v].push_back(edge(u, 0, G[u].size() - 1));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = G[u][i];
                int v = e.v, c = e.cap;
                if(c > 0 && level[v] < 0) {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    int dfs(int u, int t, int f) {
        if(u == t) {
            return f;
        }
        for(int& i = iter[u]; i < G[u].size(); i++) {
            edge& e = G[u][i];
            int v = e.v;
            int r = e.rev;
            int& c = e.cap;
            if(c > 0 && level[u] < level[v]) {
                int d = dfs(v, t, min(f, c));
                if(d > 0) {
                    c -= d;
                    G[v][r].cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    int solve(int s, int t) {
        int flow = 0;
        while(true) {
            bfs(s);
            if(level[t] < 0) {
                return flow;
            }
            int f;
            memset(iter, 0, sizeof(iter));
            while((f = dfs(s, t, INF)) > 0) {
                flow += f;
            }
        }
    }
}o;

int T, n, m, s, t, u, v, w;

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d%d%d", &n, &m, &s, &t);
        o.initGraph(n);
        while(m--) {
            scanf("%d%d%d", &u, &v, &w);
            o.addEdge(u, v, 1000 * w + 1);
        }
        printf("%d\n", o.solve(s, t) %1000);
    }
    return 0;
}
```

###  

#### 1.2.3.2 最大权闭合子图

#### 1.2.3.3 最大密度子图

### 1.2.4 有下界的网络流问题

#### 1.2.4.1 无源汇可行流

##### 例题 SGU194

题意

给一个点数为$n$的有向图网络，每条边有流量上限和流量下限。问存不存在可行流，若存在则输出可行流。

$n \leq 200$。

思路

对于每条输入边$\{u, v, c, b\}$，在图中建立一条容量为$c - b$的边将下界转化掉，然后对求得的流量加上$b$就是真正的流量。但是这样不能满足流量平衡的原则（点的入流等于点的出流）。于是应该建立超级源点$s$和超级汇点$t$，对于边$\{u, v, c, b\}$，从$u$向$s$连容量为$b$的边，$t$向$v$连容量为$b$的边（称为附加边）。对$(s, t)$求最大流，若$s$（或$t$）满流则表示存在可行流。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 210, maxm = 3e5;
const int INF = 2e9;

struct edge {
    int v, cap;
    edge() {}
    edge(int v, int cap): v(v), cap(cap) {}
};

struct Dinic {
    vector <int> G[maxn];
    vector <edge> edges;
    int level[maxn], iter[maxn];
    void initGraph(int n) {
        edges.clear();
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, int w) {
        G[u].push_back(edges.size());
        edges.push_back(edge(v, w));
        G[v].push_back(edges.size());
        edges.push_back(edge(u, 0));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = edges[G[u][i]];
                int v = e.v;
                int c = e.cap;
                if(c > 0 && level[v] < 0) {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    int dfs(int u, int t, int f) {
        if(u == t) {
            return f;
        }
        for(int& i = iter[u]; i < G[u].size(); i++) {
            edge& e = edges[G[u][i]];
            edge& re = edges[G[u][i] ^ 1];
            int v = e.v;
            int& c = e.cap;
            if(c > 0 && level[u] < level[v]) {
                int d = dfs(v, t, min(f, c));
                if(d > 0) {
                    c -= d;
                    re.cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    int solve(int s, int t) {
        int flow = 0;
        while(true) {
            bfs(s);
            if(level[t] < 0) {
                return flow;
            }
            int f;
            memset(iter, 0, sizeof(iter));
            while((f = dfs(s, t, INF)) > 0) {
                flow += f;
            }
        }
    }
};

// 需要在Dinic里进行的操作全被封装进了这个类
struct BoundFlow {
    Dinic o;
    int b[maxm], d[maxm];
  	// 调用图和本类的初始化
    void initGraph(int n) {
        memset(d, 0, sizeof(d));
        o.initGraph(n + 2);
    }
    void addEdge(int idx, int u, int v, int ub, int lb) {
        o.addEdge(u, v, ub - lb);
        b[idx] = lb;
        d[u] -= lb;
        d[v] += lb;
    }
    bool solve(int n) {
        int s = n + 1;
        int t = n + 2;
        int sum = 0;
        for(int i = 1; i <= n; i++) {
            if(d[i] > 0) {
                o.addEdge(s, i, d[i]);
                sum += d[i];
            }
            else {
                o.addEdge(i, t, -d[i]);
            }
        }
        return sum == o.solve(s, t);
    }
  	// 传入边的编号，返回边的流量
    int getFlow(int idx) {
        return b[idx] + o.edges[2 * idx - 1].cap;
    }
}oo;

int n, m, sum, u, v, c, b;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        cin >> u >> v >> b >> c;
        oo.addEdge(i, u, v, c, b);
    }
    if(oo.solve(n)) {
        cout << "YES" << endl;
        for(int i = 1; i <= m; i++) {
            cout << oo.getFlow(i) << endl;
        }
    }
    else {
        cout << "NO" << endl;
    }
    return 0;
}
```

#### 1.2.4.2 有源汇最小流

##### 例题 SGU176

题意

有一个含有$N$个点的网络，其中点$1$为源点，点$N$为汇点。网络上的每个边有一定的容量，另外有些边要求必须满流。问从源点到汇点的最小流是多少。

$N$不超过$100$，容量不超过$10^5$。

思路

这是一个有上下界的有源汇最小流。解决方法是：

1. 按照无源汇可行流那样建图（边上的容量减去下界）
2. 按照无源汇可行流那样建立附加源汇点和附加边（容量为下界）。
3. 从附加源点向附加汇点跑最大流。
4. 从汇点小源点建立容量为无穷大的边（称为汇源边）。
5. 从附加源点向附加汇点跑最大流。
6. 汇源边的流量为解。
7. 每个边的流量加下界就是真正的最小流。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 110, maxm = maxn * maxn;
const int INF = 1e9;

struct edge {
    int v, cap;
    edge() {}
    edge(int v, int cap): v(v), cap(cap) {}
};

struct Dinic {
    vector <int> G[maxn];
    vector <edge> edges;
    int level[maxn], iter[maxn];
    void initGraph(int n) {
        edges.clear();
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v, int w) {
        G[u].push_back(edges.size());
        edges.push_back(edge(v, w));
        G[v].push_back(edges.size());
        edges.push_back(edge(u, 0));
    }
    void bfs(int s) {
        queue <int> q;
        q.push(s);
        memset(level, -1, sizeof(level));
        level[s] = 0;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i = 0; i < G[u].size(); i++) {
                edge& e = edges[G[u][i]];
                int v = e.v;
                int c = e.cap;
                if(c > 0 && level[v] < 0) {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    int dfs(int u, int t, int f) {
        if(u == t) {
            return f;
        }
        for(int& i = iter[u]; i < G[u].size(); i++) {
            edge& e = edges[G[u][i]];
            edge& re = edges[G[u][i] ^ 1];
            int v = e.v;
            int& c = e.cap;
            if(c > 0 && level[u] < level[v]) {
                int d = dfs(v, t, min(f, c));
                if(d > 0) {
                    c -= d;
                    re.cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    int solve(int s, int t) {
        int flow = 0;
        while(true) {
            bfs(s);
            if(level[t] < 0) {
                return flow;
            }
            int f;
            memset(iter, 0, sizeof(iter));
            while((f = dfs(s, t, INF)) > 0) {
                flow += f;
            }
        }
    }
};

struct BoundFlow {
    Dinic o;
    int b[maxm], d[maxm];
    void initGraph(int n) {
        memset(d, 0, sizeof(d));
        o.initGraph(n + 2);
    }
    void addEdge(int idx, int u, int v, int ub, int lb) {
        o.addEdge(u, v, ub - lb);
        b[idx] = lb;
        d[u] -= lb;
        d[v] += lb;
    }
    // 返回最小流，若无可行流返回-1
    int solve(int n, int s, int t, int INF) {
        int sups = n + 1;
        int supt = n + 2;
        int sum = 0;
        for(int i = 1; i <= n; i++) {
    		if(d[i] > 0) {
    			o.addEdge(sups, i, d[i]);
    			sum += d[i];
    		}
    		else {
    			o.addEdge(i, supt, -d[i]);
    		}
    	}
        int res = o.solve(sups, supt);
        o.addEdge(t, s, INF);
        res += o.solve(sups, supt);
        if(res != sum) {
            return -1;
        }
        return o.edges[o.G[1].back()].cap;
    }
    int getFlow(int idx) {
        return b[idx] + o.edges[2 * idx - 1].cap;
    }
}oo;

int n, m, s, t, u, v, sum, ans, c, k;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; i++) {
		cin >> u >> v >> c >> k;
		if(k == 0) {
			oo.addEdge(i, u, v, c, 0);
		}
		else {
			oo.addEdge(i, u, v, c, c);
		}
	}
    ans = oo.solve(n, 1, n, INF);
	if(ans != -1) {
		cout << ans << endl;
		for(int i = 1; i < m; i++) {
			cout << oo.getFlow(i) << ' ';
		}
		cout << oo.getFlow(m) << endl;
	}
	else {
		cout << "Impossible" << endl;
	}
    return 0;
}
```

#### 1.2.4.3 有源汇最小费用可行流

##### 例题 UVALive7670(2016 ACM/ICPC Asia Beijing)

题意

有一个$n \times n$的棋盘。棋盘上放着黑棋子或白棋子（给出棋盘的状态）。给$\frac{n \times n}{2}$个棋子对使得每个棋子恰好属于一个棋子对，并且每个棋子对必同行或同列。问最少执行几次棋子对的交换（棋子对的两个棋子发生交换，没有哪个棋子能发生两次交换）使得第$i$行的黑子的数量介于$Rl_i$到$Rh_i$之间，第$j$列的黑子的数量介于$Cl_j$到$Ch_j$之间。

$n$是不超过$50$的偶数。

思路

根据数量转移关系对棋盘建立网络模型。令点$i$和点$n + j$分别表示棋盘第$i$行和棋盘第$j$列。令点$s, t$表示源汇点。定义边$(u, v, ub, lb, cost)$，表示从$u$到$v$的流量上下界为$ub, lb$的费用为$cost$的边。那么建图方式如下：

1. 从源点到表示行的点$i$建立边$(s, i, R[i], R[i], 0)$，$R[i]$表示该行有多少黑子。这种建边方式表示每行在初始状态必须有固定的黑子数量。（列也是如此）
2. 从表示行的点$i$建立边$(i, t, Rh[i], Rl[i], 0)$。这种建边方式表示每行在最终状态必须有固定范围内的黑子数量。（列也是如此）
3. 对每个颜色不同的在同列的棋子对，从黑子向白子建立边$(x1, x2 + n, 1, 0, 1)$，这种建边方式表示棋子的交换。（对颜色不同的同行的棋子也是如此）

接下来先对图进行重构以支持上下界限制。令点$sups, supt$为超级源汇点。将边$(u, v, ub, lb, cost)$拆成$3$条边（其中第二种叫源附加边，第三种叫汇附加边）：

1. $(u, v, ub - lb, 0, cost)$
2. $(sups, v, lb, 0, cost)$
3. $(u, supt, lb, 0, cost)$

再将图转化为无源无汇的图（所谓的“循环流图”）。方法是建边$(t, s, INF, black, 0)$，其中$black$为棋盘上黑子的总数。

最后求新图跑以$sups$为源点，$supt$为终点，$sum$（源附加边的$lb$之和）为流量的最小费用流。结果就是答案（若没有结果则无解）。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> P;
const int maxn = 60, INF = 2e9;
const int maxv = 110;

struct Edge {
    int to, cap, cost, rev;
    Edge() {}
    Edge(int to, int cap, int cost, int rev):
        to(to), cap(cap), cost(cost), rev(rev) {}
};

struct MCF {
    vector <Edge> G[maxv];
    // 最短路中的前驱节点和对应的边
    int prevv[maxv], preve[maxv];
    // 最短距离
    int dist[maxv];
    // 顶点的势
    int h[maxv];
    int V;
    // 使用前务必调用次函数
    void initGraph(int n) {
        V = n;
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int from, int to, int cap, int cost) {
        G[from].push_back(Edge(to, cap, cost, G[to].size()));
        G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
    }
    // 返回最小费用
    // 如果没有流量达到f的流，则返回-1
    int solve(int s, int t, int f) {
        int res = 0;
        memset(h, 0, sizeof(h));
        while(f > 0) {
            // 使用Dijkstra算法更新h
            priority_queue < P, vector<P>, greater<P> > que;
            fill(dist + 1, dist + V + 1, INF);
            dist[s] = 0;
            que.push(P(0, s));
            while(!que.empty()) {
                P p = que.top();
                que.pop();
                int u = p.second;
                if(dist[u] < p.first) {
                    continue;
                }
                for(int i = 0; i < G[u].size(); i++) {
                    Edge &e = G[u][i];
                    int v = e.to;
                    int cost = e.cost;
                    int cap = e.cap;
                    int tmp = dist[u] + cost + h[u] - h[v];
                    if(cap > 0 && dist[v] > tmp) {
                        dist[v] = tmp;
                        prevv[v] = u;
                        preve[v] = i;
                        que.push(P(dist[v], v));
                    }
                }
            }
            // 不能再增广
            if(dist[t] == INF) {
                return -1;
            }
            for(int v = 1; v <= V; v ++) {
                h[v] += dist[v];
            }
            // 沿s到t的最短路尽量增广
            int d = f;
            for(int v = t; v != s; v = prevv[v]) {
                d = min(d, G[prevv[v]][preve[v]].cap);
            }
            f -= d;
            res += d * h[t];
            for(int v = t; v != s; v = prevv[v]) {
                Edge &e = G[prevv[v]][preve[v]];
                e.cap -= d;
                G[v][e.rev].cap += d;
            }
        }
        return res;
    }
};

struct BoundFlow {
    MCF o;
    int sups, supt, sum;
//    int b[maxe];
    void initGraph(int n) {
        o.initGraph(n + 2);
        sups = n + 1;
        supt = n + 2;
        sum = 0;
    }
    void addEdge(int idx, int u, int v, int ub, int lb, int cost) {
        o.addEdge(sups, v, lb, cost);
        o.addEdge(u, supt, lb, cost);
        o.addEdge(u, v, ub - lb, cost);
        sum += lb;
//        b[idx] = lb;
    }
    // 共有m + 1条有下界的边
    int solve(int n, int m, int s, int t, int lb, int INF) {
        // 注意这是有下界的边
        addEdge(m + 1, t, s, INF, lb, 0);
        return o.solve(sups, supt, sum);
    }
}oo;

int n, s, t, N, M, Rl, Rh, Cl, Ch, a1, b1, a2, b2, black;
int R[maxn], C[maxn], G[maxn][maxn];

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    while(cin >> n) {
        s = 2 * n + 1;
        t = 2 * n + 2;
        N = 2 * n + 2;
        M = 0;
        black = 0;
        memset(R, 0, sizeof(R));
        memset(C, 0, sizeof(C));
        oo.initGraph(N);
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                cin >> G[i][j];
                R[i] += G[i][j];
                C[j] += G[i][j];
                black += G[i][j];
            }
        }
        for(int i = 1; i <= n; i++) {
            oo.addEdge(++ M, s, i, R[i], R[i], 0);
            oo.addEdge(++ M, s, n + i, C[i], C[i], 0);
        }
        for(int i = 1; i <= n; i++) {
            cin >> Rl >> Rh;
            oo.addEdge(++ M, i, t, Rh, Rl, 0);
        }
        for(int i = 1; i <= n; i++) {
            cin >> Cl >> Ch;
            oo.addEdge(++ M, n + i, t, Ch, Cl, 0);
        }
        for(int i = 1; i <= n * n / 2; i++) {
            cin >> a1 >> b1 >> a2 >> b2;
            if(G[a1][b1] == G[a2][b2]) {
                continue;
            }
            if(G[a2][b2] == 1) {
                swap(a1, a2);
                swap(b1, b2);
            }
            if(a1 == a2) {
                oo.o.addEdge(n + b1, n + b2, 1, 1);
            }
            else {
                oo.o.addEdge(a1, a2, 1, 1);
            }
        }
        cout << oo.solve(N, M, s, t, black, INF) << endl;
    }
    return 0;
}
```



### 1.2.5 线性规划问题

#### 1.2.5.1 单纯形算法

代码

```c++
const int maxn = 1005, maxm = 10005;
const double eps = 1e-7, inf = 1e10;

struct Simplex {
    double ans, A[maxm][maxn], B[maxm], C[maxn];
    inline void pivot(int n, int m, int l, int e) {
        B[l] /= A[l][e];
        for(int i = 1; i <= n; ++i) {
            if (i != e) {
                A[l][i] /= A[l][e];
            }
        }
        A[l][e] = 1 / A[l][e];
        for(int i = 1; i <= m; ++i) {
            if(i != l && fabs(A[i][e]) > eps){
                B[i] -= B[l] * A[i][e];
                for(int j = 1; j <= n; ++j) {
                    if (j != e) {
                        A[i][j] -= A[l][j] * A[i][e];
                    }
                }
                A[i][e] = -A[l][e] * A[i][e];
            }
        }
        ans += B[l] * C[e];
        for (int i = 1; i <= n; ++i) {
            if (i != e) {
                C[i] -= C[e] * A[l][i];
            }
        }
        C[e] = -C[e] * A[l][e];
    }
    double solve(int n, int m) {
        int e;
        while(true) {
            for(e = 1; e <= n; ++e) {
                if (C[e] > eps) {
                    break;
                }
            }
            if(e == n + 1) {
                break;
            }
            double t, data = inf;
            int l;
            for(int i = 1; i <= m; ++i) {
                if(A[i][e] > eps && (t = B[i] / A[i][e]) < data){
                    data = t;
                    l = i;
                }
            }
            pivot(n, m, l, e);
        }
        return ans;
    }
};
```



#### 1.2.5.2 例题

##### 例题1 BZOJ1061

题意

有个项目有n天，每天至少需要$a_i$个志愿者。共有$m$类志愿者，每类可以从$l_i$天工作到$r_i$天，其招募费用是$c_i$元。问最少用对少钱能招募到足够的志愿者。

$n \leq 10^3, m \leq 10^4$。

思路

令$n \times m$矩阵$A$的元素$A[i][j]$表示第$j$类志愿者能否在第$i$天有空，令$m \times 1$向量$x$的元素$x[j]$表示第$j$类志愿者需要招募多少人。令$n \times 1$向量$b$的元素$b[i]$表示第$i$天需要多少志愿者。那么题目的约束可以表示为

$Ax \leq b$

用向量$c$的元素$c[j]$表示第$j$类志愿者的招募费用。其优化目标可以表示为

$\min c^T \times x$

用单纯形算法可以直接解决这一线性规划问题。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1005, maxm = 10005;
const double eps = 1e-7, inf = 1e10;

struct Simplex {
    double ans, A[maxm][maxn], B[maxm], C[maxn];
    inline void pivot(int n, int m, int l, int e) {
        B[l] /= A[l][e];
        for(int i = 1; i <= n; ++i) {
            if (i != e) {
                A[l][i] /= A[l][e];
            }
        }
        A[l][e] = 1 / A[l][e];
        for(int i = 1; i <= m; ++i) {
            if(i != l && fabs(A[i][e]) > eps){
                B[i] -= B[l] * A[i][e];
                for(int j = 1; j <= n; ++j) {
                    if (j != e) {
                        A[i][j] -= A[l][j] * A[i][e];
                    }
                }
                A[i][e] = -A[l][e] * A[i][e];
            }
        }
        ans += B[l] * C[e];
        for (int i = 1; i <= n; ++i) {
            if (i != e) {
                C[i] -= C[e] * A[l][i];
            }
        }
        C[e] = -C[e] * A[l][e];
    }
    double solve(int n, int m) {
        int e;
        while(true) {
            for(e = 1; e <= n; ++e) {
                if (C[e] > eps) {
                    break;
                }
            }
            if(e == n + 1) {
                break;
            }
            double t, data = inf;
            int l;
            for(int i = 1; i <= m; ++i) {
                if(A[i][e] > eps && (t = B[i] / A[i][e]) < data){
                    data = t;
                    l = i;
                }
            }
            pivot(n, m, l, e);
        }
        return ans;
    }
}o;

int n, m, L, R;

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) {
        scanf("%lf", &o.C[i]);
    }
    for(int i = 1; i <= m; ++i) {
        scanf("%d%d%lf", &L, &R, &o.B[i]);
        for(int j = L; j <= R; ++j) {
            o.A[i][j] ++;
        }
    }
    printf("%0.f\n", o.solve(n, m));
}
```

## 1.3 图匹配

### 1.3.1 二分图最大匹配

#### 1.3.1.1 匈牙利算法

代码

```c++
struct Hungary {
    bool use[nodeSize];
    int L, from[nodeSize];
    vector <int> G[maxL];
    void init(int sz) {
        L = sz;
        for(int i = 1; i <= L; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
    }
    bool hasUnmatch(int u) {
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if(!use[v]) {
                use[v] = true;
                if(from[v] == -1 || hasUnmatch(from[v])) {
                    from[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
    int Max() {
        int res = 0;
        memset(from, -1, sizeof(from));
        for(int i = 1; i <= L; i++) {
            memset(use, 0, sizeof(use));
            res += hasUnmatch(i);
        }
        return res;
    }
};
```

注意事项

1. 其时间复杂度为O(VE)。
2. 左点的编号是从1开始的，右点的编号是从L + 1开始的。
3. L为左部点数，G为左部点的邻接表。
4. use表示本次增广中右部点是否被搜索过，from表示右部点匹配的左部点。
5. 注意初始化。

#### 1.3.1.2 例题

##### 例题1（HDU1082）

题意

有$p$门课，$n$个学生。每门课都有若干学生，现在要为每个课程分配一名课代表，每个学生只能担任一门课的课代表，如果每个课都能找到课代表，则输出"YES"，否则"NO"。

$p$不超过$100$， $n$不超过$300$。

思路

对课程—学生关系建立一个二分图，对其进行二分图的最大匹配，如果最大匹配数等于课程数，说明能够满足要求，否则不能。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxL = 305, nodeSize = 405;
int T, p, n, num, sid, res;

struct Hungary {
    bool use[nodeSize];
    int L, from[nodeSize];
    vector <int> G[maxL];
    void init(int sz) {
        L = sz;
        for(int i = 1; i <= L; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
    }
    bool hasUnmatch(int u) {
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if(!use[v]) {
                use[v] = true;
                if(from[v] == -1 || hasUnmatch(from[v])) {
                    from[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
    int Max() {
        int res = 0;
        memset(from, -1, sizeof(from));
        for(int i = 1; i <= L; i++) {
            memset(use, 0, sizeof(use));
            res += hasUnmatch(i);
        }
        return res;
    }
}o;

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d", &p, &n);
        o.init(p);
        for(int i = 1; i <= p; i++) {
            scanf("%d", &num);
            for(int j = 1; j <= num; j++) {
                scanf("%d", &sid);
                o.addEdge(i, p + sid);
            }
        }
        res = o.Max();
        puts(res == p ? "YES" : "NO");
    }
    return 0;
}
```



### 1.3.2 二分图最小点覆盖

**二分图的性质** 

1. 二分图的最大匹配数等于最小覆盖数，即求最少的点使得每条边都至少和其中的一个点相关联，很显然直接取最大匹配的一段节点即可。
2. 二分图的独立数等于顶点数减去最大匹配数，很显然的把最大匹配两端的点都从顶点集中去掉这个时候剩余的点是独立集，这是|V|-2*|M|，同时必然可以从每条匹配边的两端取一个点加入独立集并且保持其独立集性质。
3. DAG的最小路径覆盖，将每个点拆点后作最大匹配，结果为n-m，求具体路径的时候顺着匹配边走就可以，匹配边i→j',j→k',k→l'....构成一条有向路径。
4. 最大匹配数=左边匹配点+右边未匹配点。因为在最大匹配集中的任意一条边，如果他的左边没标记，右边被标记了，那么我们就可找到一条新的增广路，所以每一条边都至少被一个点覆盖。
5. 最小边覆盖=图中点的个数-最大匹配数=最大独立集。

**二分图的判定**

1. 二分图是这样一个图： 有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！
2. 无向图G为二分图的充分必要条件是，G至少有两个顶点,且其所有回路的长度均为偶数。
3. 判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！

### 1.3.3 二分图最小边覆盖

### 1.3.4 二分图最大独立集

### 1.3.5 二分图多重匹配

#### 1.3.5.1 匈牙利算法

#### 1.3.5.2 例题

##### 例题1 POJ2289

题意

一个人通讯录中好友有许多，然后需要分组，现在告诉你不同的的人能分进小组的编号，然后问你怎么分配是小组中人最多的人最少，输出最小值。

思路

二分答案然后判断是不是能完全匹配。

代码

```c++
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <sstream>
using namespace std;

const int maxn = 2000, maxLen = 1e7;
char cs[maxLen];
int n, m, num, v, l, r, mid;

struct Hungary {
    bool vis[maxn];
    int L, cnt[maxn], from[maxn][maxn];
    vector <int> G[maxn];
    void init(int sz) {
        L = sz;
        for(int i = 1; i <= L; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
    }
    bool dfs(int u, int Max) {
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if(!vis[v]) {
                vis[v] = true;
                if(cnt[v] < Max) {
                    from[v][cnt[v]++] = u;
                    return true;
                }
                for(int j = 0; j < cnt[v]; j++) {
                    if(dfs(from[v][j], Max)) {
                        from[v][j] = u;
                        return true;
                    }
                }
            }
        }
        return false;
    }
    bool ok(int Max) {
        memset(cnt, 0, sizeof(cnt));
        for(int i = 1; i <= L; i++) {
            memset(vis, 0, sizeof(vis));
            if(!dfs(i, Max)) {
                return false;
            }
        }
        return true;
    }
}o;

int main() {
    while(scanf("%d%d", &n, &m), n) {
        o.init(n);
        for(int i = 1; i <= n; i++) {
            scanf("%s", cs);
            gets(cs);
            string s(cs);
            stringstream ss(s);
            while(ss >> v) {
                o.addEdge(i, n + v + 1);
            }
        }
        l = 0;
        r = n;
        while(r - l > 1) {
            mid = (l + r) >> 1;
            if(o.ok(mid)) {
                r = mid;
            }
            else {
                l = mid;
            }
        }
        printf("%d\n", r);
    }
    return 0;
}
```



### 1.3.6 二分图最大权匹配

#### 1.3.6.1 KM算法

代码

```c++
/*  KM算法
 *  复杂度O(nx*nx*ny)
 *  求最大权匹配
 *  若求最小权匹配，可将权值取相反数，结果取相反数
 *  点的编号从0开始
 */
struct KM {
    bool visx[N], visy[N];
    int nx, ny;             // 两边的点数
    int linker[N];          // y中各点匹配状态
    int lx[N], ly[N];       // x, y中的点标号
    int g[N][N];            //二分图描述
    int slack[N];           // 节点的松弛量
    void init(int x, int y) {
        nx = x;
        ny = y;
    }
    void addEdge(int u, int v, int w) {
        g[u][v] = w;
    }
    bool DFS(int x) {
        visx[x] = true;
        for(int y = 0; y < ny; y++) {
            if(visy[y]) {
                continue;
            }
            int tmp = lx[x] + ly[y] - g[x][y];
            if(tmp == 0) {
                visy[y] = true;
                if(linker[y] == -1 || DFS(linker[y])) {
                    linker[y] = x;
                    return true;
                }
            }
            else if(slack[y] > tmp) {
                slack[y] = tmp;
            }
        }
        return false;
    }
    int solve() {
        memset(linker, -1, sizeof(linker));
        memset(ly, 0, sizeof(ly));
        for(int i = 0; i < nx; i++) {
            lx[i] = -INF;
            for(int j = 0; j < ny; j++) {
                if(g[i][j] > lx[i]) {
                    lx[i] = g[i][j];
                }
            }
        }
        for(int x = 0; x < nx; x++) {
            for(int i = 0; i < ny; i++) {
                slack[i] = INF;
            }
            while(true) {
                memset(visx, 0, sizeof(visx));
                memset(visy, 0, sizeof(visy));
                if(DFS(x)) {
                    break;
                }
                int d = INF;
                for(int i = 0; i < ny; i++) {
                    if(!visy[i] && d > slack[i]) {
                        d = slack[i];
                    }
                }
                for(int i = 0; i < nx; i++) {
                    if(visx[i]) {
                        lx[i] -= d;
                    }
                }
                for(int i = 0; i < ny; i++) {
                    if(visy[i]) {
                        ly[i] += d;
                    }
                    else {
                        slack[i] -= d;
                    }
                }
            }
        }
        int res = 0;
        for(int i = 0; i < ny; i++) {
            if(linker[i] != -1) {
                res += g[linker[i]][i];
            }
        }
        return res;
    }
};
```



#### 1.3.6.2 例题

##### 例题1（HDU2255）

题意

村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。 另一方面,村长希望得到最大的效益。由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万。问村长怎样分配房子才能使收入最大。(村民即使有钱购买一间房子但不一定能买到,要看村长分配的)。

n不超过300。

思路

裸的二分图最大权匹配。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 305, INF = 0x3f3f3f3f;
int n, w;

struct KM {
    bool visx[N], visy[N];
    int nx, ny;             // 两边的点数
    int linker[N];          // y中各点匹配状态
    int lx[N], ly[N];       // x, y中的点标号
    int g[N][N];            //二分图描述
    int slack[N];           // 节点的松弛量
    void init(int x, int y) {
        nx = x;
        ny = y;
    }
    void addEdge(int u, int v, int w) {
        g[u][v] = w;
    }
    bool DFS(int x) {
        visx[x] = true;
        for(int y = 0; y < ny; y++) {
            if(visy[y]) {
                continue;
            }
            int tmp = lx[x] + ly[y] - g[x][y];
            if(tmp == 0) {
                visy[y] = true;
                if(linker[y] == -1 || DFS(linker[y])) {
                    linker[y] = x;
                    return true;
                }
            }
            else if(slack[y] > tmp) {
                slack[y] = tmp;
            }
        }
        return false;
    }
    int solve() {
        memset(linker, -1, sizeof(linker));
        memset(ly, 0, sizeof(ly));
        for(int i = 0; i < nx; i++) {
            lx[i] = -INF;
            for(int j = 0; j < ny; j++) {
                if(g[i][j] > lx[i]) {
                    lx[i] = g[i][j];
                }
            }
        }
        for(int x = 0; x < nx; x++) {
            for(int i = 0; i < ny; i++) {
                slack[i] = INF;
            }
            while(true) {
                memset(visx, 0, sizeof(visx));
                memset(visy, 0, sizeof(visy));
                if(DFS(x)) {
                    break;
                }
                int d = INF;
                for(int i = 0; i < ny; i++) {
                    if(!visy[i] && d > slack[i]) {
                        d = slack[i];
                    }
                }
                for(int i = 0; i < nx; i++) {
                    if(visx[i]) {
                        lx[i] -= d;
                    }
                }
                for(int i = 0; i < ny; i++) {
                    if(visy[i]) {
                        ly[i] += d;
                    }
                    else {
                        slack[i] -= d;
                    }
                }
            }
        }
        int res = 0;
        for(int i = 0; i < ny; i++) {
            if(linker[i] != -1) {
                res += g[linker[i]][i];
            }
        }
        return res;
    }
}o;

int main() {
    while(scanf("%d", &n) == 1) {
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                scanf("%d", &w);
                o.addEdge(i, j, w);
            }
        }
        o.init(n, n);
        printf("%d\n", o.solve());
    }
    return 0;
}
```

## 1.4 连通性

### 1.4.1 割点

#### 1.4.1.1 Tarjan算法

代码

```c++
struct Tarjan {
    // low[u]表示点u或u的子树通过非父子边（回边）追溯到最早的祖先节点
    // pre[u]表示的是该点的时间戳
    // dfsClock表示的是当前的时间戳
    vector <int> G[maxn];
    bool isCut[maxn];
    int low[maxn], pre[maxn];
    int dfsClock;
    void init() {
        memset(isCut, 0, sizeof(isCut));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    // 每组输入前都要清空图
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    // 这里加入的是双向边
    void addBidirEdge(int u, int v) {
        G[u].push_back(v);
        G[v].push_back(u);
    }
    // 判断图是否连通的函数
    bool isConnected(int n) {
        for(int i = 1; i <= n; i++) {
            if(pre[i] == 0) {
                return false;
            }
        }
        return true;
    }
    // child表示u在搜索树上的儿子数量
    // 而不是在原图中相邻点的数量
    void dfs(int u, int fa) {
        int child = 0;
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            child++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] < pre[u) {
                continue;
            }
            isCut[u] = true;
    	}
        if(fa < 0 && child == 1) {
            isCut[u] = false;
        }
    }
    // 在图连通的情况下
    void solve() {
        init();
        dfs(1, -1);
    }
};
```

注意事项

1. 如果图是不连通的话要修改$solve()$函数，将其改成对每个连通分量调用$dfs()$

#### 1.4.1.2 例题

##### 例题1  (POJ 1144)

题意

给一个连通无向图，求其割点的数目。图以下面方式给出：

1. 第一行包含一个整数$n$，表示点的数目。
2. 接下来若干行每行包含第$i$个点的边的信息。首先是一个整数$k$，其次有$k$个整数，每个整数$j$表示$i, j$之间有边相连（$(i, j)$的信息在第$i$行被给出后就不会在第$j$行被重复给出）。
3. 某行的$k = 0$表示该组输入结束。
4. 某组的$n = 0$表示所有输入结束。

思路

用$Tarjan$算法求出割点数目。

代码

```c++
#include <iostream>
#include <vector>
#include <cstring>
#include <sstream>
using namespace std;

const int maxn = 110;

struct Tarjan {
    vector <int> G[maxn];
    bool isCut[maxn];
    int low[maxn], pre[maxn];
    int dfsClock;
    void init() {
        memset(isCut, 0, sizeof(isCut));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addBidirEdge(int u, int v) {
        G[u].push_back(v);
        G[v].push_back(u);
    }
    void dfs(int u, int fa) {
        int child = 0;
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            child++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            int d = low[v] - pre[u];
            if(d < 0) {
                continue;
            }
            isCut[u] = true;
    	}
        if(fa < 0 && child == 1) {
            isCut[u] = false;
        }
    }
    int solve(int n) {
        init();
        dfs(1, -1);
        int res = 0;
        for(int i = 1; i <= n; i++) {
            if(isCut[i] == true) {
                res ++;
            }
        }
        return res;
    }
}o;

string s;
int n, u, v;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    while((cin >> n).get(), n) {
        o.initGraph(n);
        while(getline(cin, s)) {
            stringstream ss;
            ss << s;
            ss >> u;
            if(u == 0) {
                cout << o.solve(n) << endl;
                break;
            }
            while(ss >> v) {
                o.addBidirEdge(u, v);
            }
        }
    }
    return 0;
}
```

### 1.4.2 割边（桥）

#### 1.4.2.1 Tarjan算法

代码

```c++
struct Tarjan {
    // G[u]和I[u]分别存u的边的下一个点和u的边的编号
    vector <int> G[maxn], I[maxn];
    // 代入边的编号返回是否是桥
    bool isBridge[maxm];
    int low[maxn], pre[maxn];
    int dfsClock;
    // 输入前一定要清空图
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            I[i].clear();
        }
    }
    // 各种数组的初始化
    void init() {
        memset(isBridge, 0, sizeof(isBridge));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    // 判断图是否连通
    bool isConnected(int n) {
        for(int i = 1; i <= n; i++) {
            if(pre[i] == 0) {
                return false;
            }
        }
        return true;
    }
    // 这个函数加入的是双向边
    void addBidirEdge(int u, int v, int idx) {
        G[u].push_back(v);
        I[u].push_back(idx);
        G[v].push_back(u);
        I[v].push_back(idx);
    }
    void dfs(int u, int fa) {
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            int idx = I[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u]) {
                isBridge[idx] = true;
            }
    	}
    }
    void solve() {
        init();
        dfs(1, -1);
    }
};
```

#### 1.4.2.2 例题

##### 例题1 (HDU 3849)

题意

给一个无向图（无重边，无自环），输出这个图的桥的数量。若这个图不是连通图的话输出$0$。输入的格式是先输入点数和边数，然后输入每条边的信息。

思路

用$Tarjan$算法可以解决。另外可以根据是否所有点都有时间戳来判断图的连通性。

代码

```c++
#include <iostream>
#include <vector>
#include <map>
#include <cstring>
using namespace std;

const int maxn = 1e4 + 10, maxm = 1e5 + 10;

struct Tarjan {
    vector <int> G[maxn], I[maxn];
    bool isBridge[maxm];
    int low[maxn], pre[maxn];
    int dfsClock;
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            I[i].clear();
        }
    }
    void init() {
        memset(isBridge, 0, sizeof(isBridge));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    bool isConnected(int n) {
        for(int i = 1; i <= n; i++) {
            if(pre[i] == 0) {
                return false;
            }
        }
        return true;
    }
    void addBidirEdge(int u, int v, int idx) {
        G[u].push_back(v);
        I[u].push_back(idx);
        G[v].push_back(u);
        I[v].push_back(idx);
    }
    void dfs(int u, int fa) {
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            int idx = I[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u]) {
                isBridge[idx] = true;
            }
    	}
    }
    void solve() {
        init();
        dfs(1, -1);
    }
}o;

map <string, int> mp;
vector <string> ansu, ansv;
string su[maxm], sv[maxm];
int t, n, m, u, v, cnt, ans;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> t;
    while(t--) {
        cin >> n >> m;
        o.initGraph(n);
        mp.clear();
        cnt = 0;
        for(int i = 1; i <= m; i++) {
            cin >> su[i] >> sv[i];
            if(!mp.count(su[i])) {
                mp[su[i]] = ++cnt;
            }
            if(!mp.count(sv[i])) {
                mp[sv[i]] = ++cnt;
            }
            u = mp[su[i]];
            v = mp[sv[i]];
            o.addBidirEdge(u, v, i);
        }
        o.solve();
        if(!o.isConnected(n)) {
            cout << 0 << endl;
            continue;
        }
        ansu.clear();
        ansv.clear();
        ans = 0;
        for(int i = 1; i <= m; i++) {
            if(o.isBridge[i] == true) {
                ansu.push_back(su[i]);
                ansv.push_back(sv[i]);
                ans++;
            }
        }
        cout << ans << endl;
        for(int i = 0; i < ans; i++) {
            cout << ansu[i] << ' ' << ansv[i] << endl;
        }
    }
    return 0;
}
```

### 1.4.3 有向图的强连通分量

#### 1.4.3.1 Kosaraju算法

代码

```c++
struct SCC {
    bool used[maxn];
    int cmp[maxn];
    vector <int> vs;
    vector <int> G[maxn];
    vector <int> rG[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            rG[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
        rG[v].push_back(u);
    }
    void dfs(int u) {
        used[u] = true;
        for(int i = 0; i < G[u].size(); i++)
        if(!used[G[u][i]]) {
            dfs(G[u][i]);
        }
        vs.push_back(u);
    }
    void rdfs(int u, int k) {
        used[u] = true;
        cmp[u] = k;
        for(int i = 0; i < rG[u].size(); i++) {
            if(!used[rG[u][i]]) {
                rdfs(rG[u][i], k);
            }
        }
    }
    int solve(int n) {
        memset(used, 0, sizeof(used));
        vs.clear();
        for(int i = 1; i <= n; i++) {
            if(!used[i]) {
                dfs(i);
            }
        }
        memset(used, 0, sizeof(used));
        int k = 0;
        for(int i = vs.size() - 1; i >= 0; i--) {
            if(!used[vs[i]]) {
                rdfs(vs[i], ++k);
            }
        }
        return k;
    }
};
```

注意事项

1. 点的编号从$1$开始，所点后的点的编号还是从$1$开始。

#### 1.4.3.2 例题

##### 例题1

题意

给一个含有$N$个点和$M$条边的图，问图中哪个点能被所有点达到。
($N <= 10^4, M <= 5 \times 10 ^ 4$)

思路

对图进行强连通缩点。然后出度为$1$的缩点中的所有点就是我们要求的点。

代码

```c++
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int maxn = 1e4 + 5;

struct SCC {
    bool used[maxn];
    int cmp[maxn];
    vector <int> vs;
    vector <int> G[maxn];
    vector <int> rG[maxn];
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            rG[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
        rG[v].push_back(u);
    }
    void dfs(int u) {
        used[u] = true;
        for(int i = 0; i < G[u].size(); i++)
        if(!used[G[u][i]]) {
            dfs(G[u][i]);
        }
        vs.push_back(u);
    }
    void rdfs(int u, int k) {
        used[u] = true;
        cmp[u] = k;
        for(int i = 0; i < rG[u].size(); i++) {
            if(!used[rG[u][i]]) {
                rdfs(rG[u][i], k);
            }
        }
    }
    int solve(int n) {
        memset(used, 0, sizeof(used));
        vs.clear();
        for(int i = 1; i <= n; i++) {
            if(!used[i]) {
                dfs(i);
            }
        }
        memset(used, 0, sizeof(used));
        int k = 0;
        for(int i = vs.size() - 1; i >= 0; i--) {
            if(!used[vs[i]]) {
                rdfs(vs[i], ++k);
            }
        }
        return k;
    }
}o;

bool vis[maxn];
int n, m, k, u, v, foo, idx, cnt[maxn];

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> n >> m;
    while(m--) {
        cin >> u >> v;
        o.addEdge(u, v);
    }
    k = o.solve(n);
    for(int u = 1; u <= n; u++) {
        cnt[o.cmp[u]]++;
        for(int j = 0; j < o.G[u].size(); j++) {
            v = o.G[u][j];
            if(o.cmp[u] != o.cmp[v]) {
                vis[o.cmp[u]] = true;
            }
        }
    }
    for(int i = 1; i <= k; i++) {
        if(vis[i] == false) {
            idx = i;
            foo ++;
        }
    }
    cout << (foo == 1 ? cnt[idx] : 0) << endl;
    return 0;
}
```

### 1.4.4 2-SAT

#### 1.4.4.1 基于强连通分量的算法

代码

```c++
const int maxn = 2e5 + 5, maxv = maxn << 1;

// 变量的编号范围为[0, N)
// 点的编号范围为[0, V)
struct TwoSAT {
	int N, V;
	vector <int> G[maxv];
	vector <int> rG[maxv];
	// 后序遍历的顶点列表
	vector <int> vs;
	// 访问标记
	bool used[maxv];
	// 所属强连通分量的拓扑序
	int cmp[maxv];
	void init(int n) {
		N = n;
		V = 2 * n;
	}
	// add AND to CNF
	void addEdge(int from, int to) {
		G[from].push_back(to);
		rG[to].push_back(from);
	}
	void dfs(int v) {
		used[v] = true;
		for(int i = 0; i < G[v].size(); i++) {
			if(!used[G[v][i]]) {
				dfs(G[v][i]);
			}
		}
		vs.push_back(v);
	}
	void rdfs(int v, int k) {
		used[v] = true;
		cmp[v] = k;
		for(int i = 0; i < rG[v].size(); i++) {
			if(!used[rG[v][i]]) {
				rdfs(rG[v][i], k);
			}
		}
	}
	int scc() {
		memset(used, 0, sizeof(used));
		vs.clear();
		for(int v = 0; v < V; v++) {
			if(!used[v]) {
				dfs(v);
			}
		}
		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size() - 1; i >= 0; i--) {
			if(!used[vs[i]]) {
				rdfs(vs[i], k++);
			}
		}
		return k;
	}
	int NOT(int a) {
		return (a + N) % V;
	}
	// (a | b) <=> (!a => b & !b => a)
	void disjunc(int a, int b) {
		addEdge(NOT(a), b);
		addEdge(NOT(b), a);
	}
	// (a xor b) <=> (a | b) & (!a | !b)
	void XOR(int a, int b) {
		disjunc(a, b);
		disjunc(NOT(a), NOT(b));
	}
	// !(a xor b) <=> (!a | b) & (a & !b)
	void notXOR(int a, int b) {
		disjunc(NOT(a), b);
		disjunc(a, NOT(b));
	}
	void solve() {
		scc();
		// 判断x和!x是否在不同的强连通分量中
		for(int i = 0; i < N; i++) {
			if(cmp[i] == cmp[N + i]) {
				puts("NO");
				return;
			}
		}
		puts("YES");
		// print();
	}
	void print() {
		// 如果有解，则给出一组解
		for(int i = 0; i < N; i++) {
			if(cmp[i] > cmp[N + i]) {
				puts("true");
			}
			else {
				puts("false");
			}
		}
	}
};
```

#### 1.4.4.2 例题

##### 例题1 （Codeforces）

题意

有$n$个门，每个门有一个初始状态（开或关）。有$m$个开关，每个开关可以使其控制的们状态反转。每个门定受两个开关控制，每个开关可以控制多扇门。问有策略使得所有的门都打开。

($n \leq 10^5, m \leq 10^5$)

思路

因为每个门定受两个开关控制，所以若门刚开始为关的，则控制该门的两个开关的状态必然要不同，反之相同。那么开关的关系可以用异或表示，用$2-SAT$就能判断是否有解。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2e5 + 5, maxv = maxn << 1;
int n, m, num, u, v, r[maxn];
vector <int> d[maxn];

struct TwoSAT {
	int N, V;
	vector <int> G[maxv];
	vector <int> rG[maxv];
	vector <int> vs;
	bool used[maxv];
	int cmp[maxv];
	void init(int n) {
		N = n;
		V = 2 * n;
	}
	void addEdge(int from, int to) {
		G[from].push_back(to);
		rG[to].push_back(from);
	}
	void dfs(int v) {
		used[v] = true;
		for(int i = 0; i < G[v].size(); i++) {
			if(!used[G[v][i]]) {
				dfs(G[v][i]);
			}
		}
		vs.push_back(v);
	}
	void rdfs(int v, int k) {
		used[v] = true;
		cmp[v] = k;
		for(int i = 0; i < rG[v].size(); i++) {
			if(!used[rG[v][i]]) {
				rdfs(rG[v][i], k);
			}
		}
	}
	int scc() {
		memset(used, 0, sizeof(used));
		vs.clear();
		for(int v = 0; v < V; v++) {
			if(!used[v]) {
				dfs(v);
			}
		}
		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size() - 1; i >= 0; i--) {
			if(!used[vs[i]]) {
				rdfs(vs[i], k++);
			}
		}
		return k;
	}
	int NOT(int a) {
		return (a + N) % V;
	}
	void disjunc(int a, int b) {
		addEdge(NOT(a), b);
		addEdge(NOT(b), a);
	}
	void XOR(int a, int b) {
		disjunc(a, b);
		disjunc(NOT(a), NOT(b));
	}
	void notXOR(int a, int b) {
		disjunc(NOT(a), b);
		disjunc(a, NOT(b));
	}
	void solve() {
		scc();
		for(int i = 0; i < N; i++) {
			if(cmp[i] == cmp[N + i]) {
				puts("NO");
				return;
			}
		}
		puts("YES");
	}
	void print() {
		for(int i = 0; i < N; i++) {
			if(cmp[i] > cmp[N + i]) {
				puts("true");
			}
			else {
				puts("false");
			}
		}
	}
}o;

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++) {
		scanf("%d", &r[i]);
	}
	for(int i = 0; i < m; i++) {
		scanf("%d", &num);
		while(num--) {
			scanf("%d", &u);
			d[u - 1].push_back(i);
		}
	}
	o.init(m);
	for(int i = 0; i < n; i++) {
		u = d[i][0];
		v = d[i][1];
		if(r[i] == 0) {
			o.XOR(u, v);
		}
		else {
			o.notXOR(u, v);
		}
	}
	o.solve();
	return 0;
}
```

### 1.4.5无向图的点双连通分量

#### 1.4.5.1 Tarjan算法

代码

```c++
struct Edge {
    int u, v;
};

struct Tarjan {
    // 向bccOfV中代入一个点可以得到其所属的bcc编号
    // 向vOfBCC中代入一个bcc编号可以得到其所属的点的编号
    vector <int> bccOfV[maxn], vOfBCC[maxn];
    vector <int> G[maxn];
    int pre[maxn], iscut[maxn], bccno[maxn];
    int dfsClock, bccCnt;
    stack <Edge> S;
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addBidirEdge(int u, int v) {
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int dfs(int u, int fa) {
        int lowu = pre[u] = ++dfsClock;
        int child = 0;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            Edge e = (Edge){u, v};
            if(!pre[v]) {
                S.push(e);
                child++;
                int lowv = dfs(v, u);
                lowu = min(lowu, lowv);
                if(lowv < pre[u]) {
                    continue;
                }
                iscut[u] = true;
                vOfBCC[++bccCnt].clear();
                for(;;) {
                    Edge x = S.top();
                    S.pop();
                    if(bccno[x.u] != bccCnt) {
                        bccOfV[x.u].push_back(bccCnt);
                        vOfBCC[bccCnt].push_back(x.u);
                        bccno[x.u] = bccCnt;
                    }
                    if(bccno[x.v] != bccCnt) {
                        bccOfV[x.v].push_back(bccCnt);
                        vOfBCC[bccCnt].push_back(x.v);
                        bccno[x.v] = bccCnt;
                    }
                    if(x.u == u && x.v == v) {
                        break;
                    }
                }
            }
            else if(pre[v] < pre[u] && v != fa) {
                S.push(e);
                lowu = min(lowu, pre[v]);
            }
        }
        if(fa < 0 && child == 1) {
            iscut[u] = 0;
        }
        return lowu;
    }
    void findBcc(int n) {
        memset(iscut, 0, sizeof(iscut));
        memset(bccno, 0, sizeof(bccno));
        memset(pre, 0, sizeof(pre));
        dfsClock = bccCnt = 0;
        for(int i = 1; i <= n; i++) {
            bccOfV[i].clear();
        }
        for(int i = 1; i <= n; i++) {
            if(!pre[i]) {
                dfs(i, -1);
            }
        }
    }
};
```

注意事项

1. 双连通分量内可能只有两个点一条边。

#### 1.4.5.2 例题

##### 例题1

题意

给一个含$n$个点$m$条边的无向图，要求回答$q$个询问。每个询问包括两个点$u, v$，要求输出这两个点间有多少条不相交路径（路径之间除首尾两点外无其它点相交），可选的输出内容包括$0$条（$zero$）$1$条（$one$）和不少于$2$条（$two \  or \ more$）($n \leq 5 \times 10^3, m \leq 10^4, q \leq 10^3$)。

思路

处理出图的双连通分量。分量内的点之间定有两条不相交路径（除非分量内只有两个点），分量之间的点只有一条不相交路径当且仅当两点之间连通（可以用并查集维护连通性）。

代码

```c++
#include <iostream>
#include <cstring>
#include <vector>
#include <stack>
using namespace std;

const int maxn = 5010;

struct Edge {
    int u, v;
};

struct Tarjan {
    vector <int> bccOfV[maxn], vOfBCC[maxn];
    vector <int> G[maxn];
    int pre[maxn], iscut[maxn], bccno[maxn];
    int dfsClock, bccCnt;
    stack <Edge> S;
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
        }
    }
    void addBidirEdge(int u, int v) {
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int dfs(int u, int fa) {
        int lowu = pre[u] = ++dfsClock;
        int child = 0;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            Edge e = (Edge){u, v};
            if(!pre[v]) {
                S.push(e);
                child++;
                int lowv = dfs(v, u);
                lowu = min(lowu, lowv);
                if(lowv < pre[u]) {
                    continue;
                }
                iscut[u] = true;
                vOfBCC[++bccCnt].clear();
                for(;;) {
                    Edge x = S.top();
                    S.pop();
                    if(bccno[x.u] != bccCnt) {
                        bccOfV[x.u].push_back(bccCnt);
                        vOfBCC[bccCnt].push_back(x.u);
                        bccno[x.u] = bccCnt;
                    }
                    if(bccno[x.v] != bccCnt) {
                        bccOfV[x.v].push_back(bccCnt);
                        vOfBCC[bccCnt].push_back(x.v);
                        bccno[x.v] = bccCnt;
                    }
                    if(x.u == u && x.v == v) {
                        break;
                    }
                }
            }
            else if(pre[v] < pre[u] && v != fa) {
                S.push(e);
                lowu = min(lowu, pre[v]);
            }
        }
        if(fa < 0 && child == 1) {
            iscut[u] = 0;
        }
        return lowu;
    }
    void findBcc(int n) {
        memset(iscut, 0, sizeof(iscut));
        memset(bccno, 0, sizeof(bccno));
        memset(pre, 0, sizeof(pre));
        dfsClock = bccCnt = 0;
        for(int i = 1; i <= n; i++) {
            bccOfV[i].clear();
        }
        for(int i = 1; i <= n; i++) {
            if(!pre[i]) {
                dfs(i, -1);
            }
        }
    }
}o;

struct DisjointSet {
    int p[maxn];
    void init(int n) {
        for(int i = 1; i <= n; i++) {
            p[i] = i;
        }
    }
    int find(int u) {
        return u == p[u] ? u : p[u] = find(p[u]);
    }
    bool isJoined(int u, int v) {
        return find(u) == find(v);
    }
    void Union(int u, int v) {
        u = find(u);
        v = find(v);
        p[v] = u;
    }
}p;

int n, m, q, u, v, kase = 0;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    while(cin >> n >> m >> q, (n || m || q)) {
        o.initGraph(n);
        p.init(n);
        while(m--) {
            cin >> u >> v;
            u++, v++;
            o.addBidirEdge(u, v);
            if(!p.isJoined(u, v)) {
                p.Union(u, v);
            }
        }
        o.findBcc(n);
        cout << "Case " << ++kase << ':' << endl;
        while(q--) {
            cin >> u >> v;
            u++, v++;
            if(!p.isJoined(u, v)) {
                cout << "zero" << endl;
                continue;
            }
            bool two = false;
            for(int i = 0; i < o.bccOfV[u].size(); i++) {
                for(int j = 0; j < o.bccOfV[v].size(); j++) {
                    int bccu = o.bccOfV[u][i];
                    int bccv = o.bccOfV[v][j];
                    if(bccu == bccv && o.vOfBCC[bccu].size() > 2) {
                        i = o.bccOfV[u].size();
                        two = true;
                        break;
                    }
                }
            }
            if(two == true) {
                cout << "two or more" << endl;
            }
            else {
                cout << "one" << endl;
            }
        }
    }
    return 0;
}
```



### 1.4.6 无向图的边双连通分量

#### 1.4.6.1 Tarjan算法

代码

```c++
struct Tarjan {
    vector <int> G[maxn], I[maxn];
    bool isBridge[maxm];
    int low[maxn], pre[maxn], d[maxn];
    int dfsClock;
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            I[i].clear();
        }
    }
    void init() {
        memset(isBridge, 0, sizeof(isBridge));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    void addBidirEdge(int u, int v, int idx) {
        G[u].push_back(v);
        I[u].push_back(idx);
        G[v].push_back(u);
        I[v].push_back(idx);
    }
    void dfs(int u, int fa) {
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            int idx = I[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u]) {
                isBridge[idx] = true;
            }
    	}
    }
    int solve(int n) {
        init();
        dfs(1, -1);
        for(int u = 1; u <= n; u++) {
            for(int j = 0; j < G[u].size(); j++) {
                int v = G[u][j];
                if(low[u] != low[v]) {
                    d[low[v]] ++;
                }
            }
        }
        int res = 0;
        for(int i = 1; i <= n; i++) {
            if(d[i] == 1) {
                res ++;
            }
        }
        return (res + 1) / 2;
    }
};
```

注意事项

1. 这段代码和求割点的代码一致，low[]数组中的数天然就是双连通缩点后点的颜色（假设同一个双连通分量的颜色是相同的）
2. 这段代码中的solve()函数返回最少添加多少个边可以使得整个图变成双连通图。
3. 调用之前需要对图进行初始化，其他数组的初始化已经放在solve()函数里了（实际上是在init()函数里）

#### 1.4.6.2 例题

例题1

题意

给一个无向连通图，问最少给图加多少条边就能使图变成边双连通图。

思路

对图进行边双连通缩点（求割点），假设所点后的树中有$k$个叶子，那么答案就是$\frac{k + 1}{2}$。

代码

```c++
#include <iostream>
#include <vector>
#include <map>
#include <cstring>
using namespace std;

const int maxn = 1e3 + 10, maxm = 1e3 + 10;

struct Tarjan {
    vector <int> G[maxn], I[maxn];
    bool isBridge[maxm];
    int low[maxn], pre[maxn], d[maxn];
    int dfsClock;
    void initGraph(int n) {
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            I[i].clear();
        }
    }
    void init() {
        memset(isBridge, 0, sizeof(isBridge));
        memset(pre, 0, sizeof(pre));
        memset(low, 0, sizeof(low));
        dfsClock = 0;
    }
    void addBidirEdge(int u, int v, int idx) {
        G[u].push_back(v);
        I[u].push_back(idx);
        G[v].push_back(u);
        I[v].push_back(idx);
    }
    void dfs(int u, int fa) {
        low[u] = pre[u] = ++dfsClock;
        for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            int idx = I[u][i];
            if(v == fa) {
                continue;
            }
            if(pre[v] != 0) {
                low[u] = min(low[u], pre[v]);
                continue;
            }
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u]) {
                isBridge[idx] = true;
            }
    	}
    }
    int solve(int n) {
        init();
        dfs(1, -1);
        for(int u = 1; u <= n; u++) {
            for(int j = 0; j < G[u].size(); j++) {
                int v = G[u][j];
                if(low[u] != low[v]) {
                    d[low[v]] ++;
                }
            }
        }
        int res = 0;
        for(int i = 1; i <= n; i++) {
            if(d[i] == 1) {
                res ++;
            }
        }
        return (res + 1) / 2;
    }
}o;

int n, m, u, v;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> n >> m;
    o.initGraph(n);
    for(int i = 1; i <= m; i++) {
        cin >> u >> v;
        o.addBidirEdge(u, v, i);
    }
    cout << o.solve(n) << endl;
    return 0;
}
```

### 1.4.7 欧拉回路

#### 1.4.7.1 Fleury算法

代码

```c++
void dfs(int u) {
    for(int i = 0; i < G[u].size(); i++) {
        int ei = G[u][i];
        Edge& e = edges[ei];
        int v = e.v, w = e.w, idx = e.idx;
        if(vis[ei] == true) {
            continue;
        }
        vis[ei ^ 1] = vis[ei] = true;
        dfs(v);
        ans.push_back(p(idx, w));
    }
}
```



#### 1.4.7.2 例题

##### 例题1（SGU102）

题意

有$n$个骨牌，每个骨牌有两个相对的面写有$[1, 6]$中的数字，现在要将骨牌摆成一排，

设$i$和$i + 1$是任意相邻的两个骨牌，那么$i$和$i + 1$向邻的两个面必须有相同的数字。

求一种合法的摆法（或者声明没有合法的摆法）。

思路

由于骨牌有两个属性，因此将骨牌抽象成图的边，数字抽象成图的点，

求一个欧拉回路即可。注意，图可能不连通，并且图会有重边。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v, w, idx;
    Edge() {}
    Edge(int u, int v, int w, int idx):
        u(u), v(v), w(w), idx(idx) {}
};

typedef pair <int, int> p;
const int maxn = 10, maxm = 110;
vector <Edge> edges;
vector <int> G[maxn];
vector <p> ans;
bool vis[maxm << 1];
char ch;
int n = 6, m, u, v, odd, s, ss, idx, d[maxn];

void addEdge(int u, int v, int w, int idx) {
    G[u].push_back(edges.size());
    edges.push_back(Edge(u, v, w, idx));
}

void dfs(int u) {
    for(int i = 0; i < G[u].size(); i++) {
        int ei = G[u][i];
        Edge& e = edges[ei];
        int v = e.v, w = e.w, idx = e.idx;
        if(vis[ei] == true) {
            continue;
        }
        vis[ei ^ 1] = vis[ei] = true;
        dfs(v);
        ans.push_back(p(idx, w));
    }
}

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> m;
    for(int i = 1; i <= m; i++) {
        cin >> u >> v;
        addEdge(u, v, 1, i);
        addEdge(v, u, 0, i);
        d[u] ++;
        d[v] ++;
    }
    s = -1;
    for(int i = 0; i <= n; i++) {
        if((d[i] & 1) == 1) {
            odd ++;
            s = i;
        }
        if(d[i] > 0) {
            ss = i;
        }
    }
    if(odd != 0 && odd != 2) {
        cout << "No solution" << endl;
        return 0;
    }
    s = s == -1 ? ss : s;
    dfs(s);
    if(ans.size() != m) {
        cout << "No solution" << endl;
        return 0;
    }
    for(int i = ans.size() - 1; i >= 0; i--) {
        p cur = ans[i];
        idx = cur.first;
        ch = cur.second ? '+' : '-';
        cout << idx << ' ' << ch << endl;
    }
    return 0;
}
```

## 1.5 拓扑排序

### 1.5.1 拓扑排序

#### 1.5.1.1 基于DFS的拓扑排序算法

代码实现

```c++
struct TopoSort {
    vector <int> G[maxn];
	// c[u] = 0 means u never been visited.
	// c[u] = 1 means u has been visited.
	// c[u] = -1 means u is in the stack.
	int c[maxn];
	int t, topo[maxn];
    void initGraph(int n) {
        for(int i = 0; i < n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
    }
	// search the connected component.
	bool dfs(int u) {
		c[u] = -1;
		for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
			if(c[v] < 0) {
				return false;
			}
			if(!c[v] && !dfs(v)) {
				return false;
			}
		}
		c[u] = 1;
		topo[--t] = u;
		return true;
	}
	// return false means the graph has cycle.
	bool solve(int n) {
		t = n;
		memset(c, 0, sizeof(c));
		for(int u = 0; u < n; u++) {
			if(c[u]) {
				continue;
			}
			if(!dfs(u)) {
				return false;
			}
		}
		return true;
	}
	void output(int n) {
		for(int i = 0; i < n - 1; i++) {
			cout << topo[i] << ' ';
		}
        cout << topo[n - 1] << endl;
	}
};
```

注意事项

1. 点的编号范围是0到n - 1，输出的点的编号也是0到n - 1。
2. 使用前要先调用initGraph函数做初始化，其它初始化都在solve函数中。

#### 1.5.1.2 基于BFS的拓扑排序算法（按照点的最小字典序输出）

代码

```c++
struct TopoSort {
    vector <int> G[maxn];
    vector <int> ans;
    int m, in[maxn];
    void initGraph(int n) {
        memset(in, 0, sizeof(in));
        for(int i = 0; i < n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
        in[v] ++;
        m ++;
    }
    bool solve(int n) {
        priority_queue < int, vector<int>, greater<int> > pq;
        for(int i = 0; i < n; i++) {
            if(in[i] == 0) {
                pq.push(i);
            }
        }
        ans.clear();
        while(!pq.empty()) {
            int u = pq.top();
            pq.pop();
            ans.push_back(u);
            for(int i = 0; i < G[u].size(); i++) {
                int v = G[u][i];
                m --;
                if(-- in[v] == 0) {
                    pq.push(v);
                }
            }
        }
        return m > 0;
    }
    void output() {
        for(int i = 0; i < ans.size(); i++) {
            cout << ans[i] << ' ';
        }
        cout << endl;
    }
};
```

注意事项

1. 点的编号范围是0到n - 1，输出的点的范围是0到n - 1。
2. 调用之前先用initGraph函数来做图的初始化，其它初始化都在solve函数中。

#### 1.5.1.3 例题

##### 例题1（Ural 1022）

题意

有N个人，给出这N个人每个人的儿子的编号。

求一个排列表示这N个人，使得对每个人而言，他的儿子一定会在他后面。

思路

将每个人抽象成点，将父子关系抽象成有向边，对图做拓扑排序即可。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 110;
int n, v;

struct TopoSort {
    vector <int> G[maxn];
	// c[u] = 0 means u never been visited.
	// c[u] = 1 means u has been visited.
	// c[u] = -1 means u is in the stack.
	int c[maxn];
	int t, topo[maxn];
    void addEdge(int u, int v) {
        G[u].push_back(v);
    }
	// search the connected component.
	bool dfs(int u) {
		c[u] = -1;
		for(int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
			if(c[v] < 0) {
				return false;
			}
			if(!c[v] && !dfs(v)) {
				return false;
			}
		}
		c[u] = 1;
		topo[--t] = u;
		return true;
	}
	// return false means the graph has cycle.
	bool solve(int n) {
		t = n;
		memset(c, 0, sizeof(c));
		for(int u = 0; u < n; u++) {
			if(c[u]) {
				continue;
			}
			if(!dfs(u)) {
				return false;
			}
		}
		return true;
	}
	void output(int n) {
		for(int i = 0; i < n - 1; i++) {
			cout << topo[i] + 1 << ' ';
		}
        cout << topo[n - 1] + 1 << endl;
	}
}o;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++) {
        while(cin >> v) {
            if(v == 0) {
                break;
            }
            o.addEdge(i - 1, v - 1);
        }
    }
    o.solve(n);
    o.output(n);
    return 0;
}
```



##### 例题2（UESTC1635）

题意

给出n个仅由小写字母组成的字符串，定义一种字典序，使得这n个字符串在这种字典序下是从小到大排列的。

思路

将26个小写字母抽象成图中的点。利用每两个相邻的字符串来建立边（按照题意，假设前一个字符串的字典序比后一个小）。注意当后一个字符串是前一个字符串的子串的情况。然后对图做拓扑排序。看看是否存在合法的排序。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxv = 26;

struct TopoSort {
    vector <int> G[maxv];
    vector <int> ans;
    int m, in[maxv];
    void initGraph(int n) {
        memset(in, 0, sizeof(in));
        for(int i = 0; i < n; i++) {
            G[i].clear();
        }
    }
    void addEdge(int u, int v) {
        G[u].push_back(v);
        in[v] ++;
        m ++;
    }
    bool solve(int n) {
        priority_queue < int, vector<int>, greater<int> > pq;
        for(int i = 0; i < n; i++) {
            if(in[i] == 0) {
                pq.push(i);
            }
        }
        ans.clear();
        while(!pq.empty()) {
            int u = pq.top();
            pq.pop();
            ans.push_back(u);
            for(int i = 0; i < G[u].size(); i++) {
                int v = G[u][i];
                m --;
                if(-- in[v] == 0) {
                    pq.push(v);
                }
            }
        }
        return m > 0;
    }
    void output() {
        for(int i = 0; i < ans.size(); i++) {
            putchar(ans[i] + 'a');
        }
        puts("");
    }
}o;

const int maxn = 1010, maxLen = 210;
bool fail;
char s[maxn][maxLen];
int n;

void addEdge(char u[], char v[]) {
    int nu = strlen(u);
    int nv = strlen(v);
    for(int i = 0; i < min(nu, nv); i++) {
        int x = u[i] - 'a';
        int y = v[i] - 'a';
        if(x == y) {
            continue;
        }
        o.addEdge(x, y);
        return;
    }
    if(nu > nv) {
        fail = true;
    }
}

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%s", s[i]);
    }
    for(int i = 2; i <= n; i++) {
        addEdge(s[i - 1], s[i]);
    }
    if(!fail && !o.solve(26)) {
        o.output();
    }
    else {
        puts("-1");
    }
    return 0;
}
```



### 1.5.2 拓扑排序与动态规划

#### 1.5.2.1 例题

##### 例题1（Codeforces721C）

题意

给一个$n$个点$m$条边的有向无环图。问从$1$走到$n$能经过点的数目最多，且耗时不超过$T$的路径是那条。

$n, m$不超过$5000$， $T$不超过$10^9$。

思路

因为图是DAG，所以一定存在拓扑序。于是可以按照拓扑序的逆序来DP。令$d[i][j]$表示从$i$点到$n$点，经过的点数为j时消耗的最短时间，再用$pre[i][j]$记录路径即可。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef pair <int, int> p;
const int maxn = 5010;
bool vis[maxn];
int n, m, T, u, v, w, ans, cur, x[maxn][maxn], d[maxn][maxn];
vector <p> G[maxn];

void dfs(int u) {
    vis[u] = true;
    for(int i = 0; i < G[u].size(); i++) {
        p& node = G[u][i];
        int v = node.first;
        int w = node.second;
        if(vis[v] == false) {
            dfs(v);
        }
        for(int j = 2; j <= n; j++) {
            if(d[u][j] > d[v][j-1] + w) {
                d[u][j] = d[v][j-1] + w;
                x[u][j] = v;
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &T);
    while(m--) {
        scanf("%d%d%d", &u, &v, &w);
        G[u].push_back(p(v, w));
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            d[i][j] = T + 1;
        }
    }
    d[n][1] = 0;
    dfs(1);
    for(int j = n; j >= 1; j--) {
        if(d[1][j] <= T) {
            ans = j;
            break;
        }
    }
    printf("%d\n", ans);
    cur = 1;
    for(int i = ans; i >= 1; i--) {
        printf("%d ", cur);
        cur = x[cur][i];
    }
    return 0;
}
```