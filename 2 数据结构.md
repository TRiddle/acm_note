

# 2 数据结构

## 2.1 RMQ

### 2.1.1 静态RMQ问题

#### 2.1.1.1 ST表

代码

```c++
struct ST {
	int st[maxn][32];
	int log2[maxn];
    // 使用之前一定要初始化以2为底的对数
	inline void initLog(int n) {
		log2[1] = 0;
		for(int i = 2; i <= n; i++) {
			log2[i] = log2[i-1];
			if((1 << log2[i] + 1) == i) {
				++log2[i];
			}
		}
	}
    // 初始化稀疏表，数组的下表从0开始
	inline void init(int n, int* a) {
		for(int i = n - 1; i >= 0; i--) {
			st[i][0] = a[i];
			for(int j = 1; (i + (1 << j) - 1) < n; j++) {
				st[i][j] = __gcd(st[i][j-1], st[i+(1<<j-1)][j-1]);
			}
		}
	}
	inline int rmq(int l, int r) {
		int len = r - l + 1, k = log2[len];
		return __gcd(st[l][k], st[r-(1<<k)+1][k]);
	}
};
```

注意事项

1. 在查询之前要用initLog函数初始化对数表。

#### 2.1.1.2 例题

##### 例题1 POJ 3264

题意

有由N个数组成的序列。回答关于它的Q个询问，每个询问的格式为：输出区间 $[l_i, r_i]$ 上的最大值和最小值的差。（ $N \leq 5 \times 10^4, Q \leq 2 \times 10^5$ ）

思路

因为只有关于区间最大值和最小值的询问而没有修改操作，所以可以用稀疏表来表示序列，然后在稀疏表上回答每个询问。本题要修改模板中的函数，以同时预处理出最大值的稀疏表和最小值的稀疏表。

代码

```c++
#include <iostream>
using namespace std;

const int maxn = 2e5 + 5;
int N, Q, l, r, a[maxn];

struct ST {
	int st[maxn][32][2];
	int log2[maxn];
	inline void initLog(int n) {
		log2[1] = 0;
		for(int i = 2; i <= n; i++) {
			log2[i] = log2[i-1];
			if((1 << log2[i] + 1) == i) {
				++log2[i];
			}
		}
	}
	inline void init(int* a, int n) {
		for(int i = n - 1; i >= 0; i--) {
			st[i][0][0] = st[i][0][1] = a[i];
			for(int j = 1; (i + (1 << j) - 1) < n; j++) {
				st[i][j][0] = max(st[i][j-1][0], st[i+(1<<j-1)][j-1][0]);
                st[i][j][1] = min(st[i][j-1][1], st[i+(1<<j-1)][j-1][1]);
			}
		}
	}
	inline int rmq(int l, int r, int op) {
		int len = r - l + 1, k = log2[len];
        if(op == 0) {
            return max(st[l][k][0], st[r-(1<<k)+1][k][0]);
        }
        else {
            return min(st[l][k][1], st[r-(1<<k)+1][k][1]);
        }
	}
}o;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    o.initLog(maxn - 1);
    cin >> N >> Q;
    for(int i = 0; i < N; i++) {
        cin >> a[i];
    }
    o.init(a, N);
    while(Q--) {
        cin >> l >> r;
        cout << o.rmq(l - 1, r - 1, 0) - o.rmq(l - 1, r - 1, 1) << endl;
    }
    return 0;
}
```

### 2.1.2 动态RMQ问题（点修改）

#### 2.1.2.1 线段树

```c++

#define mid ((l + r) >> 1)
#define rch (k << 1 | 1)
#define lch (k << 1)
#define RRR rch, mid + 1, r
#define LLL lch, l, mid
#define UUU 1, 1, n

struct Tree {
    int data[maxn << 2];
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
    void build(int k, int l, int r) {
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int v, int k, int l, int r) {
        if(l == r) {
            data[k] = v;
            return;
        }
		a <= mid ? update(a, v, LLL) : update(a, v, RRR);
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        int res = -1;
		res = a <= mid ? max(res, query(a, b, LLL)) : res;
		res = b > mid ? max(res, query(a, b, RRR)) : res;
        return res;
    }
};
```

#### 2.1.2.2 例题

##### 例题1 HDU 1754

题意

有一个长度为 $N$ 的序列，我们需要对其做 $M$ 次操作，第 $i$ 次操作的格式为 $(c_i, a_i, b_i)$ 。当 $c_i$ 为 $'Q'$ 时查询区间 $[a_i, b_i]$ 之间的最大值，当 $c_i$ 为 $'C'$ 时将第 $a_i$ 个元素修改成 $b_i$ 。

思路

本题需要对一个序列点修改和区间查询，用线段树维护这个序列可以完成这些工作。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2e5 + 5;

#define mid ((l + r) >> 1)
#define rch (k << 1 | 1)
#define lch (k << 1)
#define RRR rch, mid + 1, r
#define LLL lch, l, mid
#define UUU 1, 1, n

struct Tree {
    int data[maxn << 2];
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
    void build(int k, int l, int r) {
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int v, int k, int l, int r) {
        if(l == r) {
            data[k] = v;
            return;
        }
		a <= mid ? update(a, v, LLL) : update(a, v, RRR);
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        int res = -1;
		res = a <= mid ? max(res, query(a, b, LLL)) : res;
		res = b > mid ? max(res, query(a, b, RRR)) : res;
        return res;
    }
}o;

string s;
int n, m, u, v;

int main() {
	ios::sync_with_stdio(false);
    cin.tie(0);
	while(cin >> n >> m) {
		o.build(UUU);
		while(m--) {
			cin >> s >> u >> v;
			if(s == "U") {
				o.update(u, v, UUU);
				continue;
			}
			cout << o.query(u, v, UUU) << endl;
		}
	}
    return 0;
}
```

### 2.1.3 动态RMQ（区间修改）

#### 2.1.3.1 线段树

代码

```c++
#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

const int maxn = 1e5 + 5;

struct Tree {
    int data[maxn << 2];
    int lazy[maxn << 2];
	// 向上总结
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
	// 将懒惰标记下压
    void pushDown(int k) {
        if(lazy[k] == -1) {
            return;
        }
        lazy[lch] = lazy[rch] = lazy[k];
        data[lch] = data[rch] = lazy[k];
        lazy[k] = -1;
    }
	// 建树
    void build(int k, int l, int r) {
        lazy[k] = -1;
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
	// 更新操作
    void update(int a, int b, int v, int k, int l, int r) {
		// 注意这里是直接修改而不是累加
        if(a <= l && r <= b) {
            data[k] = lazy[k] = v;
            return;
        }
        pushDown(k);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k);
        int res = -1;
        res = a <= mid ? max(res, query(a, b, LLL)) : res;
        res = b > mid ? max(res, query(a, b, RRR)) : res;
        pushUp(k);
        return res;
    }
};
```

注意事项

1. 如果更新操作是累加而不是直接修改的话就不能将懒惰标记修改式下压，而是累加式下压。
2. 注意修改之前和查询之前都要先将懒惰标记下压，在值有可能被更新的时候都要向上更新。

#### 2.1.3.2 例题

##### 例题1（自编, 通过随机数据）

题意

有一个由$N$个数组成的序列，要求回答$M$次询问，当询问类型为$U$的时候将$[l, r]$上的值全部改成$v$，当询问类型为$Q$时输出$[l, r]$上的最大值。

思路

序列的区间修改和区间查询问题，可以用带懒惰标记的线段树解决。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

const int maxn = 1e5 + 5;

struct Tree {
    int data[maxn << 2];
    int lazy[maxn << 2];
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
    void pushDown(int k) {
        if(lazy[k] == -1) {
            return;
        }
        lazy[lch] = lazy[rch] = lazy[k];
        data[lch] = data[rch] = lazy[k];
        lazy[k] = -1;
    }
    void build(int k, int l, int r) {
        lazy[k] = -1;
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int b, int v, int k, int l, int r) {
        if(a <= l && r <= b) {
            data[k] = lazy[k] = v;
            return;
        }
        pushDown(k);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k);
        int res = -1;
        res = a <= mid ? max(res, query(a, b, LLL)) : res;
        res = b > mid ? max(res, query(a, b, RRR)) : res;
        pushUp(k);
        return res;
    }
}o;

string opt;
int n, q, a, b, v;

int main() {
    cin >> n >> q;
    o.build(1, 1, n);
    while(q--) {
        cin >> opt >> a >> b >> v;
        if(opt == "U") {
            o.update(a, b, v, 1, 1, n);
            continue;
        }
        cout <<  o.query(a, b, 1, 1, n) << endl;
    }
    return 0;
}
```

### 2.1.4 动态RMQ（区间累加）

#### 2.1.4.1 线段树

代码

```c++
#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

struct Tree {
    ll data[maxn << 2];
    ll lazy[maxn << 2];
    void pushUp(ll k) {
        data[k] = min(data[lch], data[rch]);
    }
	void addLazy(ll& y, ll x) {
		y = y >= 0 ? y + x : x;
	}
    void pushDown(ll k) {
        if(lazy[k] == -1) {
            return;
        }
		addLazy(lazy[lch], lazy[k]);
		addLazy(lazy[rch], lazy[k]);
        data[lch] += lazy[k];
        data[rch] += lazy[k];
        lazy[k] = -1;
    }
    void build(ll k, ll l, ll r) {
        lazy[k] = -1;
        if(l == r) {
            scanf("%I64d", &data[k]);
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(ll a, ll b, ll v, ll k, ll l, ll r) {
		if(a <= l && r <= b) {
			addLazy(lazy[k], v);
            data[k] += v;
            return;
        }
        pushDown(k);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    ll query(ll a, ll b, ll k, ll l, ll r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k);
        ll res = INF;
        res = a <= mid ? min(res, query(a, b, LLL)) : res;
        res = b > mid ? min(res, query(a, b, RRR)) : res;
        pushUp(k);
        return res;
    }
};
```

注意事项

1. $lazy$数组的默认值为$-1$所以不能直接向$lazy$数组累加值，累加前要先判断$lazy$数组的值是否为默认值

#### 2.1.4.2 例题

##### 例题1（自编, 通过随机数据）

题意

有一个由$N$个数组成的序列，要求回答$M$次询问，当询问类型为$U$的时候将$[l, r]$上的值全部累加上$v$，当询问类型为$Q$时输出$[l, r]$上的最大值。

思路

序列的区间累加和区间查询问题，可以用带懒惰标记的线段树解决。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

typedef long long ll;
const ll maxn = 1e5 + 10, INF = LLONG_MAX;

struct Tree {
    ll data[maxn << 2];
    ll lazy[maxn << 2];
    void pushUp(ll k) {
        data[k] = min(data[lch], data[rch]);
    }
	void addLazy(ll& y, ll x) {
		y = y >= 0 ? y + x : x;
	}
    void pushDown(ll k) {
        if(lazy[k] == -1) {
            return;
        }
		addLazy(lazy[lch], lazy[k]);
		addLazy(lazy[rch], lazy[k]);
        data[lch] += lazy[k];
        data[rch] += lazy[k];
        lazy[k] = -1;
    }
    void build(ll k, ll l, ll r) {
        lazy[k] = -1;
        if(l == r) {
            scanf("%I64d", &data[k]);
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(ll a, ll b, ll v, ll k, ll l, ll r) {
		if(a <= l && r <= b) {
			addLazy(lazy[k], v);
            data[k] += v;
            return;
        }
        pushDown(k);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    ll query(ll a, ll b, ll k, ll l, ll r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k);
        ll res = INF;
        res = a <= mid ? min(res, query(a, b, LLL)) : res;
        res = b > mid ? min(res, query(a, b, RRR)) : res;
        pushUp(k);
        return res;
    }
}o;

char s[10];
ll n, q, l, r, v;

int main() {
    scanf("%d%d", &n, &q);
    o.build(1, 1, n);
    while(q--) {
        scanf("%s", s);
        scanf("%d%d%I64d", &l, &r, &v);
        if(s[0] == 'Q') {
            printf("%I64d\n", o.query(l, r, 1, 1, n));
        }
        else {
            o.update(l, r, v, 1, 1, n);
        }
    }
    return 0;
}
```
## 2.2 RSQ

#### 2.2.1 动态RSQ（点累加, 区间查询）

#### 2.2.1.1 树状数组

代码

```c++
struct Tree {
    int c[maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    // 更新或者建树的函数
    // 有可能是直接修改（这里是累加修改）
    void update(int n, int pos, int val) {
        for(; pos <= n; pos += lowbit(pos)) {
            c[pos] += val;
        }
    }
    int query(int pos) {
        int res = 0;
        for(; pos > 0; pos -= lowbit(pos)) {
            res += c[pos];
        }
        return res;
    }
    int sum(int l, int r) {
        return query(r) - query(l - 1);
    }
};
```

注意事项

1. 每组建树之前要用$init()$来清空数组（如果修改时累加修改的话）

#### 2.2.1.2 例题

##### 例题1

题意

有一个长度为 $N(N \leq 5 \times 10^4)$ 的序列，我们要回答 $Q(Q \leq 4 \times 10^4)$ 次询问，询问类型及回答方式如下：

1. Query l r: 输出 $[l, r]$ 区间上的元素的和。
2. Add pos val: 为序列pos位置上的元素加上val
3. Sub pos val: 为序列pos位置上的元素减去val

(序列初始值最大为 $50$ ,  $pos$ 保证合法，$val$的最大值为$30$)

思路

对于单点修改，区间查询形的$RSQ$问题，可以用树状数组解决。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 5e4 + 10;

struct Tree {
    int c[maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    void update(int n, int pos, int val) {
        for(; pos <= n; pos += lowbit(pos)) {
            c[pos] += val;
        }
    }
    int query(int pos) {
        int res = 0;
        for(; pos > 0; pos -= lowbit(pos)) {
            res += c[pos];
        }
        return res;
    }
    int sum(int l, int r) {
        return query(r) - query(l - 1);
    }
}o;

char s[10];
int T, n, num, x, y;

int main() {
    scanf("%d", &T);
    for(int kase = 1; kase <= T; kase++) {
        scanf("%d", &n);
        o.init();
        for(int i = 1; i <= n; i++) {
            scanf("%d", &num);
            o.update(n, i, num);
        }
        printf("Case %d:\n", kase);
        while(scanf("%s", s), s[0] != 'E') {
            scanf("%d%d", &x, &y);
            if(s[0] == 'Q') {
                printf("%d\n", o.sum(x, y));
            }
            else if(s[0] == 'A') {
                o.update(n, x, y);
            }
            else {
                o.update(n, x, -y);
            }
        }
    }
    return 0;
}
```

### 2.2.2 动态RSQ（区间累加, 点查询）

#### 2.2.2.1 树状数组

代码

注意事项

#### 2.2.2.2 例题

### 2.2.3 动态RSQ（区间累加, 区间查询）

#### 2.2.3.1 树状数组

代码

```c++
struct Tree {
    ll c[2][maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    void update(int idx, int n, int pos, ll val) {
        for(; pos <= n; pos += lowbit(pos)) {
            c[idx][pos] += val;
        }
    }
    ll query(int idx, int pos) {
        ll res = 0;
        for(; pos > 0; pos -= lowbit(pos)) {
            res += c[idx][pos];
        }
        return res;
    }
    void updateRange(int n, int l, int r, ll x) {
        update(0, n, l, -(l - 1) * x);
        update(0, n, r + 1, r * x);
        update(1, n, l, x);
        update(1, n, r + 1, -x);
    }
    ll sum(int l, int r) {
        ll res = 0;
        res += query(0, r) + r * query(1, r);
        res -= query(0, l - 1) + (l - 1) * query(1, l - 1);
        return res;
    }
};
```

注意事项

1. 令$preSum(i) = c_0 + i \times  c_1$

2. 若想将区间$[l, r]$里的元素增加$x$，那么应该做如下操作

   | 数据           | 操作            |
   | ------------ | ------------- |
   | $c_1[l]$     | add $x$       |
   | $c_1[r + 1]$ | add $-x$      |
   | $c_0[l]$     | add $-(l-1)x$ |
   | $c_0[r + 1]$ | add $rx$      |

3. 若想对区间 $[l, r]$ 做$RSQ$，那么应该结果就是$ans = query(c_0, r) + r \times query(c_1, r) - query(c_0, l - 1) - (l - 1) \times query(c_1, l - 1)$

4. $c_1$ 中存的是积累量的前缀和， $c_0$ 中存的是 $c_1$ 中积累量的修正值，最后 $c_0$ 加回的是 $rx$ 而不是 $(l - 1)x$ ，这是因为对 $[l, r]$ 的累加在 $r$ 之后的影响都是恒定的 $(r - l + 1)x$ 。

#### 2.2.3.2 例题

##### 例题1

题意

有一个长度为$N$的序列，初始所有元素都为$0$。有$N$次对序列的修改，每次将区间$[l, r]$中的所有元素增加$1$。最后要求输出修改后的序列。

思路

这是一个区间累加单点查询的$RSQ$题目。但是也可以用区间查询的方法来做。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 1e5 + 10;

struct Tree {
    ll c[2][maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    void update(int idx, int n, int pos, ll val) {
        for(; pos <= n; pos += lowbit(pos)) {
            c[idx][pos] += val;
        }
    }
    ll query(int idx, int pos) {
        ll res = 0;
        for(; pos > 0; pos -= lowbit(pos)) {
            res += c[idx][pos];
        }
        return res;
    }
    void updateRange(int n, int l, int r, ll x) {
        update(0, n, l, -(l - 1) * x);
        update(0, n, r + 1, r * x);
        update(1, n, l, x);
        update(1, n, r + 1, -x);
    }
    ll sum(int l, int r) {
        ll res = 0;
        res += query(0, r) + r * query(1, r);
        res -= query(0, l - 1) + (l - 1) * query(1, l - 1);
        return res;
    }
}o;

int n, l, r;

int main() {
    while(scanf("%d", &n) == 1) {
        o.init();
        for(int i = 1; i <= n; i++) {
            scanf("%d%d", &l, &r);
            o.updateRange(n, l, r, 1);
        }
        for(int i = 1; i <= n; i++) {
            printf("%lld", o.sum(i, i));
            putchar(i == n ? '\n' : ' ');
        }
    }
    return 0;
}
```

### 2.2.4 动态 RSQ（区间修改, 区间查询）

#### 2.2.4.1 线段树

代码

```c++
#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

const int maxn = 1e5 + 5;

struct Tree {
    int data[maxn << 2];
    int lazy[maxn << 2];
    void pushUp(int k) {
        data[k] = data[lch] + data[rch];
    }
    void pushDown(int k, int l, int r) {
        if(lazy[k] == -1) {
            return;
        }
        data[lch] = (mid - l + 1) * lazy[k];
        data[rch] = (r - mid) * lazy[k];
        lazy[lch] = lazy[rch] = lazy[k];
        lazy[k] = -1;
    }
    void build(int k, int l, int r) {
        lazy[k] = -1;
        if(l == r) {
            data[k] = 1;
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int b, int v, int k, int l, int r) {
        if(a <= l && r <= b) {
            data[k] = (r - l + 1) * v;
            lazy[k] = v;
            return;
        }
        pushDown(k, l, r);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k, l, r);
        int res = 0;
        res = a <= mid ? res + query(a, b, LLL) : res;
        res = b > mid ? res + query(a, b, RRR) : res;
        pushUp(k);
        return res;
    }
};
```

#### 2.2.4.2 例题

##### 例题1(HDU 1698)

题意

有一个刚开始值全为$N$的序列，对其执行$Q$个操作，每个操作可以将区间$[l, r]$内的元素全部改为$1，2$或者是$3$。问在所有操作结束后整个序列的所有元素的和是多少。
（$N, Q \leq 10^5, l, r$保证合法）

思路

对序列区间修改前查询的问题可以用线段树高效地解决。

代码

```c++
#include <iostream>
using namespace std;

#define mid ((l + r) >> 1)
#define lch (k << 1)
#define rch (k << 1 | 1)
#define LLL lch, l, mid
#define RRR rch, mid + 1, r

const int maxn = 1e5 + 5;

struct Tree {
    int data[maxn << 2];
    int lazy[maxn << 2];
    void pushUp(int k) {
        data[k] = data[lch] + data[rch];
    }
    void pushDown(int k, int l, int r) {
        if(lazy[k] == -1) {
            return;
        }
        data[lch] = (mid - l + 1) * lazy[k];
        data[rch] = (r - mid) * lazy[k];
        lazy[lch] = lazy[rch] = lazy[k];
        lazy[k] = -1;
    }
    void build(int k, int l, int r) {
        lazy[k] = -1;
        if(l == r) {
            data[k] = 1;
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int b, int v, int k, int l, int r) {
        if(a <= l && r <= b) {
            data[k] = (r - l + 1) * v;
            lazy[k] = v;
            return;
        }
        pushDown(k, l, r);
        a <= mid ? update(a, b, v, LLL), 0 : 0;
        b > mid ? update(a, b, v, RRR), 0 : 0;
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        pushDown(k, l, r);
        int res = 0;
        res = a <= mid ? res + query(a, b, LLL) : res;
        res = b > mid ? res + query(a, b, RRR) : res;
        pushUp(k);
        return res;
    }
}o;

int T, n, q, a, b, v;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> T;
    for(int kase = 1; kase <= T; kase++) {
        cin >> n;
        o.build(1, 1, n);
        cin >> q;
        while(q--) {
            cin >> a >> b >> v;
            o.update(a, b, v, 1, 1, n);
        }
        cout << "Case " << kase;
        cout << ": The total value of the hook is ";
        cout << o.query(1, n, 1, 1, n) << ".\n";
    }
    return 0;
}
```

[TOC]

## 2.3 2D数据结构

### 2.3.1 2DRSQ(点累加，区域查询)

#### 2.3.1.1 树状数组

代码

```c++
struct Tree {
    int c[maxn][maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    // 为点(x, y)累加一个值
    // n, m为x, y的上界
    // x, y的下界为1
    void add(int x, int y, int v, int n, int m) {
        for(int i = x; i <= n; i += lowbit(i)) {
            for(int j = y; j <= m; j += lowbit(j)) {
                c[i][j] += v;
            }
        }
    }
    int query(int x, int y) {
        int res = 0;
        for(int i = x; i > 0; i -= lowbit(i)) {
            for(int j = y; j > 0; j -= lowbit(j)) {
                res += c[i][j];
            }
        }
        return res;
    }
    // 对一个矩形区域加和，下标从1开始
    int sum(int x1, int y1, int x2, int y2) {
        int res = query(x2, y2);
        res -= query(x1 - 1, y2);
        res -= query(x2, y1 - 1);
        res += query(x1 - 1, y1 - 1);
        return res;
    }
};
```

注意事项

1. 使用前要调用$init()$ 函数做初始化。
2. $sum()$ 函数的前两个值表示 $x, y$ 都相对较小的点的坐标，后者则相反。

#### 2.3.1.2 例题

##### 例题1（HDU 2642）

题意

有一个二维平面直角坐标系，初始所有点的点权为0。我们要相应M条命令。命令类型如下：

1. B x y：让坐标为(x, y)的点的权值为1
2. D x y：让坐标为(x, y)的点的权值为0
3. Q x1 x2 y1 y2：查询这四个坐标值对应的矩形区域内的所有点的点权和。

($M \leq 10^5, 0 \leq x, y \leq 10^3$)

思路

本题为平面内的点修改，矩形区域RSQ问题，可以用二维BIT来解决。需要注意的是，本题的点的下标是从0开始的，因此要转换成从1开始的点的坐标。另外，为了放防止对已经置1的点进行重复累加，我们要用数组G[][]来做判重，这样会比直接用二维BIT判断要省时间。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 10;

struct Tree {
    int c[maxn][maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    void add(int x, int y, int v, int n, int m) {
        for(int i = x; i <= n; i += lowbit(i)) {
            for(int j = y; j <= m; j += lowbit(j)) {
                c[i][j] += v;
            }
        }
    }
    int query(int x, int y) {
        int res = 0;
        for(int i = x; i > 0; i -= lowbit(i)) {
            for(int j = y; j > 0; j -= lowbit(j)) {
                res += c[i][j];
            }
        }
        return res;
    }
    int sum(int x1, int y1, int x2, int y2) {
        int res = query(x2, y2);
        res -= query(x1 - 1, y2);
        res -= query(x2, y1 - 1);
        res += query(x1 - 1, y1 - 1);
        return res;
    }
};

char s[5];
int q, x1, x2, y1, y2;
int G[maxn][maxn];

int main() {
    freopen("Input.txt", "r", stdin);
    memset(G, 0, sizeof(G));
    scanf("%d", &q);
    o.init();
    while(q--) {
        scanf("%s", s);
        if(s[0] == 'B') {
            scanf("%d%d", &x1, &y1);
            x1++, y1++;
            if(G[x1][y1] == 0) {
                o.add(x1, y1, 1, maxn - 1, maxn - 1);
                G[x1][y1] = 1;
            }
        }
        else if(s[0] == 'D') {
            scanf("%d%d", &x1, &y1);
            x1++, y1++;
            if(G[x1][y1] == 1) {
                o.add(x1, y1, -1, maxn - 1, maxn - 1);
                G[x1][y1] = 0;
            }
        }
        else {
            scanf("%d%d%d%d", &x1, &x2, &y1, &y2);
            x1++, x2++;
            y1++, y2++;
            if(x1 > x2) {
                swap(x1, x2);
            }
            if(y1 > y2) {
                swap(y1, y2);
            }
            printf("%d\n", o.sum(x1, y1, x2, y2));
        }
    }
    return 0;
}
```

### 2.3.1 2DRSQ（区域累加，点查询）

#### 2.3.1.1 2D树状数组

代码

（如点修改，区间查询的代码）

注意事项

1. 在处理区间修改，点查询时可以像处理一维的情况那样用树状数组维护前缀和。
2. 当修改 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的区域时 $(x_1 < x_2, y_1 < y_2)$ ，修改以下四个位置即可： $(x_1, y_1), (x_1, y_2 + 1), (x_2 + 1, y_1), (x_2 + 1, y_2 + 1)$ 。

#### 2.3.1.2 例题

##### 例题1（POJ2155）

题意

给一个 $n \times n$ 的网格（每个格子中有一个初始为关闭的开关），我们需处理q个询问，对于每个询问可以操作点 $(x_1, y_1)$ 和点 $(x_2, y_2)$ 之间区域的开关一次，或者查询点 $(x, y)$ 出的开关的开闭状态。回答每一个查询。

思路

二维空间的区间修改，点查询问题可以通过用二维树状数组来维护二维前缀和来处理。另外本题给出的点的下标可能为 $0$ ，所以输入的点的下标要自增 $1$ 。由于本题对区间的修改是“开关型”修改，所以每次修改只要累加 $1$ ，最后结果模 $2$ 即可。

代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int maxn = 1e3 + 10;

struct Tree {
    int c[maxn][maxn];
    void init() {
        memset(c, 0, sizeof(c));
    }
    int lowbit(int x) {
        return x & -x;
    }
    void add(int x, int y, int v, int n, int m) {
        for(int i = x; i <= n; i += lowbit(i)) {
            for(int j = y; j <= m; j += lowbit(j)) {
                c[i][j] += v;
            }
        }
    }
    int query(int x, int y) {
        int res = 0;
        for(int i = x; i > 0; i -= lowbit(i)) {
            for(int j = y; j > 0; j -= lowbit(j)) {
                res += c[i][j];
            }
        }
        return res;
    }
    int sum(int x1, int y1, int x2, int y2) {
        int res = query(x2, y2);
        res -= query(x1 - 1, y2);
        res -= query(x2, y1 - 1);
        res += query(x1 - 1, y1 - 1);
        return res;
    }
}o;

string s;
int T, n, q, x1, x2, y1, y2;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> T;
    while(T--) {
        cin >> n >> q;
        o.init();
        while(q--) {
            cin >> s;
            if(s[0] == 'C') {
                cin >> x1 >> y1 >> x2 >> y2;
                o.add(x2 + 1, y2 + 1, 1, n + 1, n + 1);
                o.add(x1, y2 + 1, 1, n + 1, n + 1);
                o.add(x2 + 1, y1, 1, n + 1, n + 1);
                o.add(x1, y1, 1, n + 1, n + 1);
            }
            else {
                cin >> x1 >> y1;
                cout << o.sum(1, 1, x1, y1) % 2 << endl;
            }
        }
        if(T != 0) {
            cout << endl;
        }
    }
    return 0;
}
```

## 2.4 KRMQ

### 2.4.1 静态KRMQ问题(点修改，区间查询)

#### 2.4.1.1 主席树

代码

```c++
#define mid ((l + r) >> 1)
#define rch (k << 1 | 1)
#define lch (k << 1)
#define RRR rch, mid + 1, r
#define LLL lch, l, mid
#define UUU 1, 1, n

struct Tree {
    int data[maxn << 2];
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
    void build(int k, int l, int r) {
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int v, int k, int l, int r) {
        if(l == r) {
            data[k] = v;
            return;
        }
		a <= mid ? update(a, v, LLL) : update(a, v, RRR);
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        int res = -1;
		res = a <= mid ? max(res, query(a, b, LLL)) : res;
		res = b > mid ? max(res, query(a, b, RRR)) : res;
        return res;
    }
};
```



#### 2.4.1.2 例题

##### 例题1（HDU2665）

题意

点修改，区间查询数组中的第K大元素。

思路

裸题。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2e5 + 5;

#define mid ((l + r) >> 1)
#define rch (k << 1 | 1)
#define lch (k << 1)
#define RRR rch, mid + 1, r
#define LLL lch, l, mid
#define UUU 1, 1, n

struct Tree {
    int data[maxn << 2];
    void pushUp(int k) {
        data[k] = max(data[lch], data[rch]);
    }
    void build(int k, int l, int r) {
        if(l == r) {
            cin >> data[k];
            return;
        }
        build(LLL);
        build(RRR);
        pushUp(k);
    }
    void update(int a, int v, int k, int l, int r) {
        if(l == r) {
            data[k] = v;
            return;
        }
		a <= mid ? update(a, v, LLL) : update(a, v, RRR);
        pushUp(k);
    }
    int query(int a, int b, int k, int l, int r) {
        if(a <= l && r <= b) {
            return data[k];
        }
        int res = -1;
		res = a <= mid ? max(res, query(a, b, LLL)) : res;
		res = b > mid ? max(res, query(a, b, RRR)) : res;
        return res;
    }
}o;

string s;
int n, m, u, v;

int main() {
		ios::sync_with_stdio(false);
        cin.tie(0);
		while(cin >> n >> m) {
		o.build(UUU);
		while(m--) {
			cin >> s >> u >> v;
			if(s == "U") {
				o.update(u, v, UUU);
				continue;
			}
			cout << o.query(u, v, UUU) << endl;
		}
	}
    return 0;
}
```



## 2.5 可合并集合

### 2.5.1 并查集

代码

```c++
struct DisjointSet {
    int p[maxn];
    void init(int n) {
        for(int i = 1; i <= n; i++) {
            p[i] = i;
        }
    }
    int find(int u) {
        return u == p[u] ? u : p[u] = find(p[u]);
    }
    // 判断两个元素是否在同一集合中
    bool isJoined(int u, int v) {
        return find(u) == find(v);
    }
    // 合并之前要判断是否已经合并过
    void Union(int u, int v) {
        u = find(u);
        v = find(v);
        p[v] = u;
    }
};
```

### 2.5.2 左偏树

代码

```c++
class Heap {
private:
    // 节点的容器
    int v[maxm], l[maxm], r[maxm], d[maxm];
    // 树根的容器
    int tot, Heap[maxm];
    // 复杂度O(logn)
    // 输入要合并的两棵左偏树的编号
    // 输出新的堆顶编号
    int merge(int x, int y) {
    	if(x == 0) {
    		return y;
    	}
    	if(y == 0) {
    		return x;
    	}
        // 小于号表示小根堆
        // 大于号表示大根堆
    	if(v[x] < v[y]) {
    		swap(x, y);
    	}
    	r[x] = merge(r[x], y);
    	if(d[l[x]] < d[r[x]]) {
    		swap(l[x], r[x]);
    	}
    	d[x] = d[r[x]] + 1;
    	return x;
    }
    // 输入单节点左偏树的权值
    // 输出新建的左偏树的编号
    int initNode(int x) {
    	v[++tot] = x;
    	l[tot] = r[tot] = d[tot] = 0;
    	return tot;
    }
    // 复杂度O(logn)
    // 向编号为x的左偏树中插入一个权值为y的节点
    // 输出新的堆顶编号
    int insert(int x, int y) {
    	return merge(Heap[x], initNode(y));
    }
public:
    // 复杂度O(1)
    // 输入左偏树的编号
    // 输出编号为x的左偏树的堆顶的权值
    int top(int x) {
    	return v[Heap[x]];
    }
    // 复杂度O(logn)
    // 输入左偏树的编号
    // 删除编号为x的左偏树的堆顶，返回新的堆顶的编号
    int pop(int x) {
    	return Heap[x] = merge(l[Heap[x]], r[Heap[x]]);
    }
    // 输入左偏树的编号
    // 判断编号为x的左偏树的堆是否为空
    bool empty(int x) {
    	return Heap[x] == 0;
    }
    // 初始化左偏树集合
    void initHeap() {
        memset(Heap, 0, sizeof(Heap));
    	tot = 0;
    }
    // 将编号为x和y的两个左偏树合并
    void join(int x, int y) {
        Heap[x] = merge(Heap[x], Heap[y]);
    }
    // 向编号为x的左偏树中加入权值为y的节点
    void push(int x, int y) {
        Heap[x] = empty(x) ? initNode(y) : insert(x, y);
    }
};
```

注意事项

1. 向左偏树模板中的函数中传入的左偏树编号是外部编号，其内部编号由tot变量控制。
2. 左偏树模板中的Heap[i]中存储的是内部编号而不是外部编号。
3. 左偏树模板中的maxm需要定义得大些。其大小应设为插入次数的上界而不是树根数量的上界。

### 2.5.3 pb_ds库中的可并堆

代码

```c++
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>

using namespace std;
using namespace __gnu_pbds;

#define param int, less<int>, binomial_heap_tag
__gnu_pbds::priority_queue<param> qs[maxn];
```

注意事项

1. pb_ds库中的可并堆支持push, pop, modify, erase, join五种操作。
2. pb_ds库中的可并堆还可以用的实现有:pairing_heap_tag, binary_heap_tag, rc_binomial_heap_tag和thin_heap_tag，其中binomial_heap_tag和pairing_heap_tag的合并效率比较高。

### 2.5.4 题目

##### 例题1（HDU 1512）

题意

有 $N$ 只富有攻击性的猴子，第 $i$ 只猴子的攻击力为 $a_i$ 。猴子们之间会形成小团体。当猴子 $A$ 和 $B$ 发生争执的时候，猴子 $A$ 的小团体中攻击力最高的猴子 $P$ 会和猴子 $B$ 的小团体中攻击力最高的猴子 $Q$ 打一架。打架的结果是两个战士 $P$ 和 $Q$ 的攻击力减半（除 $2$ 并向下取整），并合并成一个小团体。初始的时候每个猴子只和自己形成小团体。现在已知有 $M$ 次争执即将发生，第 $i$ 次争执的主角是猴子 $A_i$ 和 $B_i$ ，问每次战斗结束后合并的小团体中攻击力最高的猴子的攻击力是多少？（ $N, M \leq 10^5$ , 猴子的攻击力在 $int$ 的表示范围内）

思路

对于每次争执，我们必须迅速地知道某个猴子属于哪个小团体，在争执结束后为了处理下次询问我们还得快速地合并这两个小团体。这就要求我们使用一个可以迅速查找和合并的集合，而并查集就是这样一个集合。对于每次争执，我们必须迅速地知道某个小团体中攻击力最高的是谁，在争执结束后为了处理下次询问我们还得快速地合并这两个小团体。这就要求我们使用一个可以支持动态维护最大（小）值的可快速合并的集合，而可并堆就是这样一个集合。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5, maxm = maxn << 1;
int T, n, m, x, y, val;

// 左偏树
class Heap {
private:
    int v[maxm], l[maxm], r[maxm], d[maxm];
    int tot, Heap[maxm];
    int merge(int x, int y) {
    	if(x == 0) {
    		return y;
    	}
    	if(y == 0) {
    		return x;
    	}
    	if(v[x] < v[y]) {
    		swap(x, y);
    	}
    	r[x] = merge(r[x], y);
    	if(d[l[x]] < d[r[x]]) {
    		swap(l[x], r[x]);
    	}
    	d[x] = d[r[x]] + 1;
    	return x;
    }
    int initNode(int x) {
    	v[++tot] = x;
    	l[tot] = r[tot] = d[tot] = 0;
    	return tot;
    }
    int insert(int x, int y) {
    	return merge(Heap[x], initNode(y));
    }
public:
    int top(int x) {
    	return v[Heap[x]];
    }
    int pop(int x) {
    	return Heap[x] = merge(l[Heap[x]], r[Heap[x]]);
    }
    bool empty(int x) {
    	return Heap[x] == 0;
    }
    void initHeap() {
        memset(Heap, 0, sizeof(Heap));
    	tot = 0;
    }
    void join(int x, int y) {
        Heap[x] = merge(Heap[x], Heap[y]);
    }
    void push(int x, int y) {
        Heap[x] = empty(x) ? initNode(y) : insert(x, y);
    }
}q;

// 并查集
struct DisjointSet {
    int p[maxn];
    void init(int n) {
        for(int i = 1; i <= n; i++) {
            p[i] = i;
        }
    }
    int find(int u) {
        return u == p[u] ? u : p[u] = find(p[u]);
    }
    bool isJoined(int u, int v) {
        return find(u) == find(v);
    }
    void Union(int u, int v) {
        u = find(u);
        v = find(v);
        p[v] = u;
    }
}s;

// 按题目方式合并小团体
void joint(int u, int v) {
    u = s.find(u);
    v = s.find(v);
    int utop = q.top(u);
    q.pop(u);
    q.push(u, utop / 2);
    int vtop = q.top(v);
    q.pop(v);
    q.push(v, vtop / 2);
    q.join(u, v);
}

int main() {
    while(scanf("%d", &n) == 1) {
        s.init(n);
        q.initHeap();
        for(int i = 1; i <= n; i++) {
            scanf("%d", &val);
            q.push(i, val);
        }
        scanf("%d", &m);
        while(m--) {
            scanf("%d%d", &x, &y);
            if(s.isJoined(x, y)) {
                cout << -1 << endl;
                continue;
            }
            joint(x, y);
            cout << q.top(s.find(x)) << endl;
            s.Union(x, y);
        }
    }
    return 0;
}
```
## 2.6 字符串

### 2.6.1 KMP

#### 2.6.1.1 KMP算法

代码

```c++
struct KMP {
    string t, p;
    int tn, pn;
    int next[maxp];
    void init(string t0, string p0) {
        tn = (t = t0).size();
        pn = (p = p0).size();
        getNext();
    }
    void getNext() {
        int j = 0, k = -1;
        next[j] = k;
        while(j < pn) {
            if(k == -1 || p[k] == p[j]) {
                next[++j] = ++k;
                continue;
            }
            k = next[k];
        }
    }
    // 返回首次出现模式串的文本串下标
    int find() {
        int i = 0, j = 0;
        while(i < tn && j < pn) {
            if(j == -1 || t[i] == p[j]) {
                i++;
                j++;
            }
            else {
                j = next[j];
            }
        }
        if(j == pn) {
            return i - j;
        }
        return -1;
    }
    // 返回文本串中模式串的个数
    int count() {
        int j = 0, ans = 0;
        for(int i = 0; i < tn; i++) {
            while(j && t[i] != p[j]) {
                j = next[j];
            }
            if(t[i] == p[j]) {
                j++;
            }
            if(j == pn) {
                j = next[j];
                ans++;
            }
        }
        return ans;
    }
};
```

注意事项

1. 每组开始的时候要调用$init()$函数，在$init()$函数中文本串$t$，模式串$p$和$next$数组都得以初始化。
2. 模板中的字符串的下标都是以$0$开始的。

#### 2.6.1.2 例题

##### 例题1（POJ 3461）

题意

输入两个字符串，输出第一个字符串在第二个字符串中的出现次数。

思路

用$KMP$算法即可。

代码

```c++
#include <iostream>
using namespace std;

const int maxp = 1e4 + 10;
string t, p;
int T;

struct KMP {
    string t, p;
    int tn, pn;
    int next[maxp];
    void init(string t0, string p0) {
        tn = (t = t0).size();
        pn = (p = p0).size();
        getNext();
    }
    void getNext() {
        int j = 0, k = -1;
        next[j] = k;
        while(j < pn) {
            if(k == -1 || p[k] == p[j]) {
                next[++j] = ++k;
                continue;
            }
            k = next[k];
        }
    }
    int count() {
        int j = 0, ans = 0;
        for(int i = 0; i < tn; i++) {
            while(j && t[i] != p[j]) {
                j = next[j];
            }
            if(t[i] == p[j]) {
                j++;
            }
            if(j == pn) {
                j = next[j];
                ans++;
            }
        }
        return ans;
    }
}o;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    cin >> T;
    while(T--) {
        cin >> p >> t;
        o.init(t, p);
        cout << o.count() << endl;
    }
    return 0;
}
```

<br>

### 2.6.2 Trie

#### 2.6.2.1 模板

#### 2.6.2.2 字符串集

#### 2.6.2.3 二进制数集

##### 例题1 HDU5536 (2015 ACM/ICPC Asia Changchun)

题意

给长度的为$n$的数组$a$，找出三个数$i、j$和$k$，使得$a[i] \oplus a[j] \oplus a[k]$最大。

$n \leq 1000$。

思路

将所有的数转化成32位二进制数，然后存入字典树里面。枚举a[i]和a[j]，将它们从字典树中删去，然后贪心地从字典树中查找a[k]。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 10, maxNode = 1e7;
int t, n, a[maxn], ans;

struct trie {
	int sz, val[maxNode], ch[maxNode][2];
	void init() {
		memset(ch[0], 0, sizeof(ch[0]));
		sz = 1;
	}
	void update(int num, int v) {
		int u = 0;
		for(int i = 30; i >= 0; i--) {
			int c = (num >> i) & 1;
			if(ch[u][c] == 0) {
				memset(ch[sz], 0, sizeof(ch[sz]));
				val[sz] = 0;
				ch[u][c] = sz++;
			}
			u = ch[u][c];
			val[u] += v;
		}
	}
	int match(int num) {
		int u = 0, ans = 0;
		for(int i = 30; i >= 0; i--) {
			int c = (num >> i) & 1;
			if(ch[u][c^1] && val[ch[u][c^1]]) {
				ans |= (1 << i);
				u = ch[u][c^1];
			}
			else u = ch[u][c];
		}
		return ans;
	}
}o;

int main() {
	scanf("%d", &t);
	for(; t--;) {
		scanf("%d", &n);
		o.init();
		for(int i = 0; i < n; i++) {
			scanf("%d", &a[i]);
			o.update(a[i], 1);
		}
		ans = 0;
		for(int i = 0; i < n; i++) {
			o.update(a[i], -1);
			for(int j = i + 1; j < n; j++) {
				o.update(a[j], -1);
				int tmp = o.match(a[i] + a[j]);
				ans = max(ans, tmp);
				o.update(a[j], 1);
			}
			o.update(a[i], 1);
		}
		printf("%d\n", ans);
	}
	return 0;
}
```



##### 例题2 UVALive7943 (2014 ACM/ICPC Asia Xian)

题意

有$n$个IP地址集，每个IP地址集的格式为$a.b.c.d/e$,表示IP地址$a.b.c.d$的二进制表示的前$e$位固定，

其余位任意的情况下所能表达的IP地址构成的集合。

要求用尽可能少的上述IP地址集表示给定的$n$个IP地址集在IP地址空间下的补集。

$n \leq 3\times10^4, 0 \leq a, b, c, d \leq 256$。

思路

将这些地址集的二进制形式插入Trie中，每个地址只插入长度为$e$的前缀。

从根节点开始对Trie进行DFS，当某个节点缺少左子树或者右子树时，

输出缺少的那棵子树对应的地址集。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef unsigned int bits;
const int maxn = 3e4 + 10;
const int maxNode = 32 * maxn, sigmaSize = 2;
vector <string> ans;
int b;

struct Trie {
    int ch[maxNode][sigmaSize];
    int val[maxNode];
    int sz;
    void init() {
        sz = 1;
        memset(ch[0], 0, sizeof(ch[0]));
        memset(val, 0, sizeof(val));
    }
    void newnode(int u, char c) {
        memset(ch[sz], 0, sizeof(ch[sz]));
        val[sz] = 0;
        ch[u][c] = sz ++;
    }
    void insert(int x, int d) {
        int u = 0;
        for(int i = 31; i >= 31 - d + 1; i--) {
            int c = (x >> i) & 1;
            if(!ch[u][c]) {
                newnode(u, c);
            }
            u = ch[u][c];
        }
        val[u] = 1;
    }
	int a[100];
	void dfs(int u, int dep) {
		if(val[u]) {
			return;
		}
		a[dep + 1] = 0;
		if(ch[u][0]) {
			dfs(ch[u][0], dep + 1);
		}
		else {
			setAnswer(dep + 1);
		}
		a[dep + 1] = 1;
		if(ch[u][1]) {
			dfs(ch[u][1], dep + 1);
		}
		else {
			setAnswer(dep + 1);
		}
	}
	char cstr[100];
	int y[100];
	void setAnswer(int dep) {
		bits tmp = 0;
		for(int i = 1; i <= dep; i++) {
			tmp = (tmp << 1) + a[i];
		}
		for(int i = dep + 1; i <= 32; i++) {
			tmp = (tmp << 1);
		}
		for(int i = 4; i >= 1; i--) {
			y[i] = tmp % 256;
			tmp /= 256;
		}
		sprintf(cstr, "%d.%d.%d.%d/%d", y[1], y[2], y[3], y[4], dep);
		ans.push_back(string(cstr));
	}
}o;

bits num;
int T, n, x[10];

int main() {
	scanf("%d", &T);
	for(int kase = 1; kase <= T; kase++) {
		ans.clear();
		o.init();
		scanf("%d", &n);
		if(n == 0) {
			printf("Case #%d:\n1\n0.0.0.0/0\n", kase);
			continue;
		}
		for(int i = 1; i <= n; i++) {
			scanf("%d.%d.%d.%d/%d", &x[1], &x[2], &x[3], &x[4], &b);
			num = 0;
			for(int j = 1; j <= 4; j++) {
				num = (num << 8) + x[j];
			}
			o.insert(num, b);
		}
		o.dfs(0, 0);
		printf("Case #%d:\n%d\n", kase, ans.size());
		for(int i = 0; i < ans.size(); i++) {
			printf("%s\n", ans[i].c_str());
		}
	}
    return 0;
}
```

### 2.6.3 AC Automaton

#### 2.6.3.1 基于Trie的算法

代码

```c++
const char firstOne = 'a';
const int nodeSize = 5e5 + 10, sigmaSize = 26;

// 点的标号范围为[0, sz)
struct AC {
    int next[nodeSize][sigmaSize];
    int fail[nodeSize];
    int end[nodeSize];
    int root, sz;
    int idx(char ch) {
        return ch - firstOne;
    }
    void init() {
        sz = 0;
        root = newnode();
    }
    int newnode() {
        memset(next[sz], -1, sizeof(next[sz]));
        end[sz] = 0;
        return sz++;
    }
    void insert(char buf[]) {
        int len = strlen(buf);
        int now = root;
        for(int i = 0; i < len; i++) {
            int c = idx(buf[i]);
            if(next[now][c] == -1) {
                next[now][c] = newnode();
            }
            now = next[now][c];
        }
        end[now]++;
    }
    void walkSuffixLink() {
        // 构建Trie图时根据fail数组修改end数组的函数
    }
    void build() {
        queue <int> Q;
        fail[root] = root;
        for(int i = 0; i < sigmaSize; i++) {
            if(next[root][i] == -1) {
                next[root][i] = root;
            }
            else {
                fail[next[root][i]] = root;
                Q.push(next[root][i]);
            }
        }
        while(!Q.empty()) {
            int now = Q.front();
            Q.pop();
            walkSuffixLink();
            for(int i = 0; i < sigmaSize; i++) {
                if(next[now][i] == -1) {
                    next[now][i] = next[fail[now]][i];
                }
                else {
                    fail[next[now][i]] = next[fail[now]][i];
                    Q.push(next[now][i]);
                }
            }
        }
    }
    // 输入文本串
    // 输出文本串中含有的模式串的数量
    int query(char buf[]) {
        int len = strlen(buf);
        int now = root;
        int res = 0;
        for(int i = 0; i < len; i++) {
            int c = idx(buf[i]);
            now = next[now][c];
            int temp = now;
            while(temp != root) {
                res += end[temp];
                end[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};
```

注意事项

1. 注意$firstOne$和$sigmaSize$两个参数共同构成了自动机的字符集。

#### 2.6.3.2 例题

##### 例题1（HDU 2222）

题意

给$N(N <= 10^4)$个不超过$50$个小写字母的关键词，再给一段文本，问这段文本中包含多少关键词。

思路

将用这些单词的$Trie$树构建$AC$自动机，然后将文本作为自动机的输入即可。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const char firstOne = 'a';
const int nodeSize = 5e5 + 10, sigmaSize = 26;
const int maxLen = 1e6 + 10;
char s[maxLen];
int t, n;

struct AC {
    int next[nodeSize][sigmaSize];
    int fail[nodeSize];
    int end[nodeSize];
    int root, sz;
    int idx(char ch) {
        return ch - firstOne;
    }
    void init() {
        sz = 0;
        root = newnode();
    }
    int newnode() {
        memset(next[sz], -1, sizeof(next[sz]));
        end[sz] = 0;
        return sz++;
    }
    void insert(char buf[]) {
        int len = strlen(buf);
        int now = root;
        for(int i = 0; i < len; i++) {
            int c = idx(buf[i]);
            if(next[now][c] == -1) {
                next[now][c] = newnode();
            }
            now = next[now][c];
        }
        end[now]++;
    }
    void build() {
        queue <int> Q;
        fail[root] = root;
        for(int i = 0; i < sigmaSize; i++) {
            if(next[root][i] == -1) {
                next[root][i] = root;
            }
            else {
                fail[next[root][i]] = root;
                Q.push(next[root][i]);
            }
        }
        while(!Q.empty()) {
            int now = Q.front();
            Q.pop();
            for(int i = 0; i < sigmaSize; i++) {
                if(next[now][i] == -1) {
                    next[now][i] = next[fail[now]][i];
                }
                else {
                    fail[next[now][i]] = next[fail[now]][i];
                    Q.push(next[now][i]);
                }
            }
        }
    }
    int query(char buf[]) {
        int len = strlen(buf);
        int now = root;
        int res = 0;
        for(int i = 0; i < len; i++) {
            int c = idx(buf[i]);
            now = next[now][c];
            int temp = now;
            while(temp != root) {
                res += end[temp];
                end[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
}o;

int main() {
    scanf("%d", &t);
    while(t--) {
        scanf("%d", &n);
        o.init();
        for(int i = 0; i < n; i++) {
            scanf("%s", s);
            o.insert(s);
        }
        o.build();
        scanf("%s", s);
        printf("%d\n", o.query(s));
    }
    return 0;
}
```

### 2.6.4 SAM

#### 2.6.4.1 构建算法

```c++
const char firstOne = 'a';
const int maxn = 5010, sigmaSize = 26;

struct SAM {
	int cur, last, res;
	int pre[maxn], step[maxn];
	int next[maxn][sigmaSize];
	void newnode(int s) {
		step[++ cur] = s;
		pre[cur] = 0;
		memset(next[cur], 0, sizeof(next[cur]));
	}
	int idx(char ch) {
		return ch - firstOne;
	}
	void init() {
		res = 0;
		cur = 0;
		last = 1;
		newnode(0);
	}
	int insert(char ch) {
		newnode(step[last] + 1);
		int v = idx(ch);
		int p = last;
		int np = cur;
		for(; p && !next[p][v]; p = pre[p]) {
			next[p][v] = np;
		}
		if(p != 0) {
			int q = next[p][v];
			if(step[q] == step[p] + 1) {
				pre[np] = q;
			}
			else {
				newnode(step[p] + 1);
				int nq = cur;
				copy(next[q], next[q] + sigmaSize, next[nq]);
				pre[nq] = pre[q];
				pre[np] = pre[q] = nq;
				for(; p && next[p][v] == q; p = pre[p]) {
					next[p][v] = nq;
				}
			}
		}
		else {
			pre[np] = 1;
		}
		res += step[np] - step[pre[np]];
		last = np;
		return res;
	}
};
```

#### 2.6.4.2 例题

##### 例题1(HDU 4622)

题意

给定一个字符串$s$，对其处理$Q$个查询，每个查询为一个区间$[l, r]$，求区间中不同子串的个数。
($|s| \leq 2 \times 10^3, Q \leq 10^4, l, r \in [1, n]$)

思路

用后缀自动机预处理后输出。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const char firstOne = 'a';
const int maxn = 5010, sigmaSize = 26;
char s[maxn];
int T, n, q, u, v;
int ans[maxn][maxn];

struct SAM {
	int cur, last, res;
	int pre[maxn], step[maxn];
	int next[maxn][sigmaSize];
	void newnode(int s) {
		step[++ cur] = s;
		pre[cur] = 0;
		memset(next[cur], 0, sizeof(next[cur]));
	}
	int idx(char ch) {
		return ch - firstOne;
	}
	void init() {
		res = 0;
		cur = 0;
		last = 1;
		newnode(0);
	}
	int insert(char ch) {
		newnode(step[last] + 1);
		int v = idx(ch);
		int p = last;
		int np = cur;
		for(; p && !next[p][v]; p = pre[p]) {
			next[p][v] = np;
		}
		if(p != 0) {
			int q = next[p][v];
			if(step[q] == step[p] + 1) {
				pre[np] = q;
			}
			else {
				newnode(step[p] + 1);
				int nq = cur;
				copy(next[q], next[q] + sigmaSize, next[nq]);
				pre[nq] = pre[q];
				pre[np] = pre[q] = nq;
				for(; p && next[p][v] == q; p = pre[p]) {
					next[p][v] = nq;
				}
			}
		}
		else {
			pre[np] = 1;
		}
		res += step[np] - step[pre[np]];
		last = np;
		return res;
	}
}o;

int main () {
	scanf("%d", &T);
	while (T--) {
		scanf("%s", s);
		n = strlen(s);
		for(int i = 0; i < n; i++) {
			o.init();
			for(int j = i; j < n; j++) {
				ans[i + 1][j + 1] = o.insert(s[j]);
			}
		}
		scanf("%d", &q);
		while(q--) {
			scanf("%d%d", &u, &v);
			printf("%d\n", ans[u][v]);
		}
	}
	return 0;
}
```

### 2.6.5 Manacher

#### 2.6.5.1 算法

代码

```c++
struct Manacher {
    // p[i]表示加入#号后的字符串以s[i]为中心的最长回文子串向左或向右扩张的长度
    // 两倍内存以存下额外的#号
    int p[maxLen << 1];
    string s;
    void init(string a) {
        s = "#";
        for(int i = 0; i < a.size(); i++) {
            s.push_back(a[i]);
            s.push_back('#');
        }
        memset(p, 0, sizeof(p));
    }
    void preSolve() {
        // 最大回文子串的边界
        int mx = 0;
        // 最大回文子串的中心位置
        int id;
        for(int i = 0; i < s.size(); i++) {
            // mx > i, p[i] >= min(p[2 * id - i], mx - i)
            if(mx > i) {
                p[i] = min(p[2 * id - i], mx - i);
            }
            // mx <= i, 无法对p[i]做更多的假设
            else {
                p[i] = 1;
            }
            while(s[i + p[i]] == s[i - p[i]]) {
                if(i - p[i] < 0 || i + p[i] >= s.size()) {
                    break;
                }
                p[i]++;
            }
            if(p[i] + i > mx) {
                mx = p[i] + i;
                id = i;
            }
        }
    }
    int solve() {
        int res = 0;
        preSolve();
        for(int i = 0; i < s.size(); i++) {
            res = max(res, p[i] - 1);
        }
        return res;
    }
};
```

注意事项

1. 调用init()函数以初始化字符串（向其中加入#号）。
2. 调用solve()函数即可从返回值中获取解。

#### 2.6.4.2 例题

##### 例题1(HDU 3068)

每组样例给一个字符串（样例之间由空行隔开），输出其最长回文子串的长度。

思路

用$manacher$算法可以解决。

代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxLen = 12e5;

struct Manacher {
    int p[maxLen << 1];
    string s;
    void init(string a) {
        s = "#";
        for(int i = 0; i < a.size(); i++) {
            s.push_back(a[i]);
            s.push_back('#');
        }
        memset(p, 0, sizeof(p));
    }
    void preSolve() {
        int mx = 0;
        int id;
        for(int i = 0; i < s.size(); i++) {
            // when mx > i, p[i] >= min(p[2 * id - i], mx - i)
            if(mx > i) {
                p[i] = min(p[2 * id - i], mx - i);
            }
            else {
                p[i] = 1;
            }
            while(s[i + p[i]] == s[i - p[i]]) {
                if(i - p[i] < 0 || i + p[i] >= s.size()) {
                    break;
                }
                p[i]++;
            }
            if(p[i] + i > mx) {
                mx = p[i] + i;
                id = i;
            }
        }
    }
    int solve() {
        int res = 0;
        preSolve();
        for(int i = 0; i < s.size(); i++) {
            res = max(res, p[i] - 1);
        }
        return res;
    }
}o;

string s;

int main() {
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin.tie(0);
    while(getline(cin, s)) {
        o.init(s);
        cout << o.solve() << endl;
        cin.get();
    }
    return 0;
}
```
